{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Move"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MoveElement"
    extends="org.move.lang.core.psi.MoveElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MoveElementType"
    tokenTypeClass="org.move.lang.core.MoveTokenType"

    extends(".*SpecExpr")=SpecExpr
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends(".*Predicate")=Predicate
    extends("(Lambda|Ref|QualPath|Tuple)Type")=Type
    extends(".*SpecDef")=SpecDef

    name(".*Expr")="expression"

//    consumeTokenMethod(".*Expr") = "consumeTokenFast"

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        PLACEHOLDER_ADDRESS_IDENT='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
        PLACEHOLDER_ADDRESS_LITERAL='regexp:@\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'

        ADDRESS_IDENT='regexp:0x[0-9a-fA-F]{1,40}'
        ADDRESS_LITERAL='regexp:@0x[0-9a-fA-F]{1,40}'

        BECH32_ADDRESS_IDENT='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
        BECH32_ADDRESS_LITERAL='regexp:@wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'

        POLKADOT_ADDRESS_IDENT='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'
        POLKADOT_ADDRESS_LITERAL='regexp:@[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'

        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u64)|(u128))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
//        FUNCTION_PATTERN_NAME='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'

        ADDRESS     = 'address_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        ABORTS_IF     = 'aborts_if_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnuMoveariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | ScriptDef | AddressDef | ModuleDef)*

Attr ::= '#' '[' <<comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER AttrItemArguments?
AttrItemArguments ::= '(' <<comma_sep_items AttrItemArgument>> ')'
AttrItemArgument ::= IDENTIFIER '=' LiteralExpr

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

ScriptDef ::= script ScriptBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveImportStatementsOwner" ]
    mixin = "org.move.lang.core.psi.ext.MoveScriptDefMixin"
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | const | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= ImportStatement | ConstDef | FunctionDef

private address ::= <<addressKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MoveAddressDefMixin"
//    stubClass = "org.move.lang.core.stubs.impl.MoveAddressDefStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplFactoryKt.factory"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= ModuleDef*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= Attr* module (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "module"
    name = "module declaration"
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveImportStatementsOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveModuleDefMixin"
//    stubClass = "org.move.lang.core.stubs.impl.MoveModuleDefStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplFactoryKt.factory"
}
ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
}
private ModuleBlockItems ::= ModuleItem*
//{
//    recoverWhile = "ModuleBlockItems_recover"
//}
//private ModuleBlockItems_recover ::= !'}'

private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | const | struct | spec | Attr
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= ImportStatement | FriendStatement
                            | StructDef | FunctionDef
                            | NativeStructDef | NativeFunctionDef
                            | SpecFunctionDef
                            | ConstDef
                            | SpecDef
//private ModuleItem_item ::= ImportStatement | StructDef | NativeStructDef
//                            | FunctionDef | FunctionVisibilityContainer
//                            | NativeFunctionDef | ConstDef | ItemSpecDef

ConstDef ::= const IDENTIFIER TypeAnnotation Initializer ';'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveConstDefMixin"
//    recoverWhile = ModuleItem_recover
}
//private ConstDef_init ::= '=' Expr
//{
//    recoverWhile = "ConstDef_init_recover"
//}
//private ConstDef_init_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
//NativeFunctionDef ::= native FunctionSignature

//NativeFunctionDef ::= native FunctionVisibilityModifier?
//                      fun IDENTIFIER TypeParameterList?
//                         FunctionParameterList
//                         ReturnType?
//                         AcquiresType? ';'
//{
//    pin = "fun"
//    name = "native function"
//    implements = [
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//    mixin = "org.move.lang.core.psi.mixins.MoveNativeFunctionDefMixin"
//    recoverWhile = Item_recover
//}

//private NativeDef ::=
//{
//    pin = 1
////    recoverWhile = Item_recover
//}

SpecFunctionDef ::= (spec FunctionSignature) SpecBlock { pin = 1 }
InnerSpecFunctionDef ::= FunctionSignature SpecBlock { pin = 1 }
InnerNativeSpecFunctionDef ::= native FunctionSignature SpecBlock { pin = 1 }

NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';' { pin = 2 }
NativeStructDef ::= native StructSignature ';' { pin = 2 }

private FunctionSignatureWithOptionalVisibility ::= FunctionSignatureVisibility | FunctionSignature
private FunctionSignatureVisibility ::= FunctionVisibilityModifier FunctionSignature { pin = 1 }
FunctionSignature ::= fun IDENTIFIER TypeParameterList?
                          FunctionParameterList
                          ReturnType? AcquiresType?
{
    pin = "fun"
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionSignatureMixin"
    recoverWhile = "FunctionSignature__recover"
}
private FunctionSignature__recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

FunctionDef ::= Attr* FunctionSignatureWithOptionalVisibility CodeBlock
{
    pin = 2
//    recoverWhile = Item_recover
}
//NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';'

//FunctionDef ::= fun IDENTIFIER TypeParameterList?
//                    FunctionParameterList
//                    ReturnType? AcquiresType?
//                    CodeBlock
//{
//    pin = "fun"
//    name = "function"
//    implements = [
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
////    extends = "org.move.lang.core.psi.MoveStubbedNamedElementImpl<?>"
//    mixin = "org.move.lang.core.psi.mixins.MoveFunctionDefMixin"
//    recoverWhile = Item_recover
////    stubClass = "org.move.lang.core.stubs.MoveFunctionDefStub"
////    elementTypeFactory = "org.move.lang.core.stubs.StubImplementationsKt.factory"
//}

FunctionVisibilityModifier ::= public ('(' (script | friend) ')')?

//private FunctionReturnItems ::= ReturnType? AcquiresType?
//{
//    recoverWhile = FunctionReturnItems_recover
//}
//private FunctionReturnItems_recover ::= !(CodeBlock | ';' | Item_first)

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')'
{
    pin = 1
//    extends = "org.move.lang.core.psi.MoveStubbedElementImpl<?>"
//    stubClass = "org.move.lang.core.stubs.PlaceholderStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplementationsKt.factory"
}
//private FunctionParameterList_body ::= <<comma_separated_list FunctionParameter>> {
//    recoverWhile = "FunctionParameterList_body_recover"
//}
//private FunctionParameterList_body_recover ::= !')'

private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= IDENTIFIER TypeAnnotation
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParameterMixin"
}

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<comma_sep_items QualPathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructSignature ::= struct IDENTIFIER TypeParameterList? AbilitiesList?
{
    pin = "struct"
    implements = [
        "org.move.lang.core.psi.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructSignatureMixin"
}

StructDef ::= Attr* StructSignature StructFieldsDefBlock { pin = 2 }

//NativeStructDef ::= native resource? struct IDENTIFIER TypeParameterList? ';'
//{
//    pin = "struct"
//    implements = [
//        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
//    ]
//    mixin = "org.move.lang.core.psi.mixins.MoveNativeStructDefMixin"
//}

//StructDef ::= resource? struct IDENTIFIER
//                TypeParameterList? StructTraitList?
//                StructFieldsDefBlock
//{
//    pin = "struct"
//    implements = [
//        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MoveStructDefMixin"
//}

AbilitiesList ::= has <<comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructFieldsDefBlock ::= '{' StructFieldDef_with_recover* '}' { pin = 1 }
private StructFieldDef_with_recover ::= !'}' StructFieldDef (',' | &'}')
{
    pin = 1
    recoverWhile = StructFieldDef_recover
}
private StructFieldDef_recover ::= !('}' | IDENTIFIER)

//private StructFieldsBlock_body ::= <<comma_sep_list StructFieldDef>>?
{
//    recoverWhile = "StructFieldsBlock_body_recover"
}
//private StructFieldsBlock_body_recover ::= !'}'

StructFieldDef ::= IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructFieldDefMixin"
}
//private StructFieldDef_type ::= TypeAnnotation
//{
//    recoverWhile = "StructFieldDef_type_recover"
//}
//private StructFieldDef_type_recover ::= !(','|'}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'
//ImportStatement ::= use ModuleRef ('::' Import) ';'
//{
//    pin = 1
//}

//ImportStatement ::= use AddressRef '::' Import ';'
//{
//    pin = 1
//}
FriendStatement ::= friend FullyQualifiedModuleRef ';' { pin = 1 }

ImportStatement ::= Attr* use (ModuleItemsImport | ModuleImport) ';'
{
    pin = "use"
}
//private ImportStatement_recover ::= !ModuleItem_first
//private ImportStatement_body ::= ModuleItemsImport | ModuleImport

//private ImportStatement_body ::= AddressRef '::' Import
//{
//    recoverWhile = ImportStatement_body_recover
//}
//private ImportStatement_body_recover ::= !';'

//Import ::= ItemImport | ModuleImport
ModuleImport ::= FullyQualifiedModuleRef ImportAlias?
{
//    extends = Import
    name = "qual path to imported item"
    implements = [
        "org.move.lang.core.psi.MoveNamedElement"
//        "org.move.lang.core.psi.MoveReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveModuleImportMixin"
}
ModuleItemsImport ::= FullyQualifiedModuleRef '::' (ItemImport | MultiItemImport)
{
    pin = 2
    name = "qual path to imported item"
//    extends = Import
}

MultiItemImport ::= '{' <<comma_sep_items MultiItemImport_member_with_recovery>> '}'
{
    pin = 1
}
private MultiItemImport_member_with_recovery ::= !('}' | ';' | <<eof>>) ItemImport
{
    pin = 1
}

//private MultiImportedItem_items ::= <<comma_sep_items ImportedItem>>
//{
//    recoverWhile = MultiImportedItem_items_recovery
//}
//private MultiImportedItem_items_recovery ::= !'}'

ItemImport ::= IDENTIFIER ImportAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.move.lang.core.psi.MoveNamedElement"
        "org.move.lang.core.psi.MoveReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveItemImportMixin"
}
ImportAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MoveImportAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type { pin = 1 }

Type ::= RefType | QualPathType | TupleType | LambdaType
{
    implements = ["org.move.lang.core.types.HasType"]
    mixin = "org.move.lang.core.psi.ext.MoveTypeMixin"
}

RefType ::= RefTypeStart Type
{
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MoveRefTypeMixin"
}
RefTypeStart ::= ('&' mut?)

QualPathType ::= QualPath
{
    name = "type"
    implements = [
        "org.move.lang.core.psi.MoveQualTypeReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveQualPathTypeMixin"
}

TupleType ::= '(' TupleTypeItem_with_recover* ')' { pin = 1 }
private TupleTypeItem_with_recover ::= !')' Type (',' | &')')
{
    pin = 1
    recoverWhile = TupleTypeItem_recover
}
private TupleTypeItem_recover ::= !(')' | '{' | IDENTIFIER)

LambdaType ::= '|' <<comma_sep_items Type>>? '|' Type { pin = 1 }

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
}
private TypeParameter_with_recover ::= !'>' TypeParameter (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | IDENTIFIER)

//private TypeParameterList_items ::= <<comma_sep_items TypeParameter>>
//{
//    recoverWhile = TypeParameterList_items_recovery
//}
//private TypeParameterList_items_recovery ::= !('{'|'('|'>')

TypeParameter ::= phantom? IDENTIFIER TypeParamBound? {
    pin = 2
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.types.HasType" ]
    mixin = "org.move.lang.core.psi.mixins.MoveTypeParameterMixin"
}
TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<comma_sep_items (TypeArgument &(','|'>'))>>? '>'
TypeArgument ::= Type
//private TypeArgumentList_items ::= <<comma_sep_items (QualifiedPathType &(','|'>'))>>
//{
//    recoverWhile = TypeArgumentList_items_recover
//}
//private TypeArgumentList_items_recover ::= !('>'|'('|'{')
//private TypeArgument ::= TypeRef &(','|'>')
//{
//    recoverWhile = "TypeArgument_recover"
//}
//private TypeArgument_recover ::= !(','|'>')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.types.HasType" ]
    mixin = "org.move.lang.core.psi.ext.MoveBindingPatMixin"
}

TuplePat ::= '(' <<comma_sep_items Pat>>? ')'
//private TuplePat_body ::= (<<comma_sep_list Pat>>)? {
//    recoverWhile = "TuplePat_body_recover"
//}
//private TuplePat_body_recover ::= !(')'|'=')

StructPat ::= QualPath StructPatFieldsBlock {
    implements = [
        "org.move.lang.core.psi.MoveQualTypeReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructPatMixin"
}
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

//private StructPatField_items ::= <<comma_sep_items StructPatField>>
//{
//    recoverWhile = StructPatField_items_recover
//}
//private StructPatField_items_recover ::= !'}'

StructPatField ::= IDENTIFIER StructPatFieldBinding? {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat { pin = 1 }

//private StructPatField_recovery ::= !(',' | '}' | IDENTIFIER)


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
//private Statement ::= IfStatement | LoopStatement | WhileStatement
//                            | LetStatement | AssignmentStatement
//                            | ExprStatement

Statement ::= LetStatement | (StatementExpr ';')
LetStatement ::= let Pat TypeAnnotation? Initializer? ';' {
    pin = 1
//    implements = [
//        "org.move.lang.core.types.HasType"
//    ]
//    mixin = "org.move.lang.core.psi.mixins.MoveLetStatementMixin"
}

private StatementExpr ::= IfExpr
                            | LoopExpr
                            | WhileExpr
//                            | LetExpr
//                            | AssignmentExpr
                            | Expr
{
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= !(';' | '}')

//InlineSpecBlock ::= spec SpecBlock { pin = 1 }

//IfStatement ::= IfExpr ';'
//LoopStatement ::= LoopExpr ';'
//WhileStatement ::= WhileExpr ';'

//private StatementBody ::= IfExpr

//LetStatement ::= LetStatementInner ';'
//private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
//private LetStatementInner_recover ::= !';'

//AssignmentStatement ::= AssignmentExpr ';'
//ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlockItems  '}'
{
    pin = 1
//    implements = [ "org.move.lang.core.psi.MoveImportStatementsOwner" ]
}

private CodeBlockItems ::= ImportStatement* (Statement | BlockSpecStatement)* Expr?
{
    recoverWhile = "CodeBlockItems_recover"
}
private CodeBlockItems_recover ::= !'}'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    implements = ["org.move.lang.core.types.HasType"]
    mixin = "org.move.lang.core.psi.ext.MoveExprMixin"
}
//private SpecExpr ::= Expr | AggregatePredicate

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

//private AssignmentExprItem ::= LetExpr | AssignmentExpr
private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
//IfExpr
//                    | LoopExpr
//                    | WhileExpr
//                    | LetExpr
                    AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
//                    | AssignmentExpr
                    | StructLiteralExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
                    | RangeExpr
                    | LiteralExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type
{
    mixin = "org.move.lang.core.psi.ext.MoveCastExprMixin"
}

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

MulExpr ::= Expr '*' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMulExprMixin"
}
DivExpr ::= Expr '/' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveDivExprMixin"
}
PlusExpr ::= Expr '+' Expr
{
    mixin = "org.move.lang.core.psi.ext.MovePlusExprMixin"
}
MinusExpr ::= Expr '-' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMinusExprMixin"
}

ModExpr ::= Expr '%' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveModExprMixin"
}

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExprItem ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr eqeq_gt Expr
PartialImplyOperatorExpr ::= Expr lt_eqeq_gt Expr

BangExpr ::= '!' Expr
{ mixin = "org.move.lang.core.psi.ext.MoveBangExprMixin" }

DerefExpr ::= '*' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveDerefExprMixin"
}
CopyExpr ::= copy Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveCopyExprMixin"
}
MoveExpr ::= move Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMoveExprMixin"
}

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= QualPath StructLiteralFieldsBlock
{
    implements = ["org.move.lang.core.psi.MoveQualTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveStructLiteralExprMixin"
}
StructLiteralFieldsBlock ::= '{' StructLiteralField_with_recover* '}' { pin = 1 }
//private StructLiteralFieldsBlock_items ::= <<comma_sep_items StructLiteralField>>
//{
//    recoverWhile = StructLiteralFieldsBlock_items_recovery
//}
//private StructLiteralFieldsBlock_items_recovery ::= !'}'
//private StructLiteralFieldsBlock_body ::= (StructLiteralExprField ','?)*
//{
//    recoverWhile = "StructLiteralFieldsBlock_body_recover"
//}
//private StructLiteralFieldsBlock_body_recover ::= !'}'
private StructLiteralField_with_recover ::= !'}' StructLiteralField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLiteralField_recover
}
private StructLiteralField_recover ::= !('}' | IDENTIFIER)

StructLiteralField ::= IDENTIFIER StructLiteralFieldAssignment?
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructLiteralFieldMixin"
//    recoverWhile = StructLiteralExprField_recover
}

//private StructLiteralExprField_recover ::= !(',' | '}')
StructLiteralFieldAssignment ::= ':' Expr { pin = 1 }

ParensExpr ::= '(' Expr ')'
{
    mixin = "org.move.lang.core.psi.ext.MoveParensExprMixin"
}
//private ParensExpr_body ::= Expr { recoverWhile = "ParensExpr_body_recover" }
//private ParensExpr_body_recover ::= !(':'|')'|',')
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

//TupleLiteralExpr ::= '('
//TupleLiteralExpr ::= '(' TupleLiteralExpr? ')' { pin = 2 }
//private TupleLiteralExpr_body ::= (Expr ',' (Expr ','?)*)?
LambdaExpr ::= '|' <<comma_sep_items IDENTIFIER>> '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLiteralExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LiteralExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | PLACEHOLDER_ADDRESS_LITERAL
                | ADDRESS_LITERAL
                | BECH32_ADDRESS_LITERAL
                | POLKADOT_ADDRESS_LITERAL
{
    mixin = "org.move.lang.core.psi.ext.MoveLiteralExprMixin"
}

CallExpr ::= (QualPath &'(') CallArguments
{
    pin = 1
    implements = ["org.move.lang.core.psi.MoveQualNameReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveCallExprMixin"
}

CallArguments ::= '(' <<comma_sep_items (Expr &(','|')'))>>? ')' { pin = 1 }
//private CallArgument ::= Expr {
//    recoverWhile = "CallArgument_recover"
//}
//private CallArgument_recover ::= !(','|')')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr Initializer { rightAssociative = true }

Initializer ::= '=' Expr {
    pin = 1
//    recoverWhile = "Initializer_recover"
}
//private Initializer_recover ::= !(';'|'}'|')')

BorrowExpr ::= '&' mut? Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBorrowExprMixin"
}

DotExpr ::= Expr '.' StructFieldRef
{
    mixin = "org.move.lang.core.psi.ext.MoveDotExprMixin"
}

StructFieldRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.MoveStructFieldReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveStructFieldRefMixin"
}

IndexExpr ::= Expr '[' Expr ']' { rightAssociative = true }

RefExpr ::= QualPath
{
    implements = [
        "org.move.lang.core.psi.MoveQualNameReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveRefExprMixin"
}

QualPath ::= (ModuleRef '::')? IDENTIFIER TypeArgumentList?

//LocalQualPath ::= (ModuleRef '::' &IDENTIFIER)? IDENTIFIER TypeArgumentList?
//FullyQualPath ::= (FullyQualifiedModuleRef '::' &IDENTIFIER)? IDENTIFIER TypeArgumentList?

//FullyQual
//private QualPathModulePrefix ::= (FullyQualifiedModuleRef | ModuleRef) &'::'
//QualPathStart ::= FullyQualifiedModuleRef
//{
//    pin = 1
//}
//private QualPathPrefix ::= ((FullyQualifiedModuleRef | ModuleRef) '::')

ModuleRef ::= ImportedModuleRef | FullyQualifiedModuleRef
{
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
}

ImportedModuleRef ::= IDENTIFIER
{
    extends = ModuleRef
    mixin = "org.move.lang.core.psi.ext.MoveModuleRefMixin"
}

FullyQualifiedModuleRef ::= AddressRef '::' IDENTIFIER
{
    pin = 2
    extends = ModuleRef
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveFullyQualifiedModuleRefMixin"
}

//private ADDRESS_IDENT ::= <<addressIdent>>
AddressRef ::= NamedAddress
                | PLACEHOLDER_ADDRESS_IDENT
                | BECH32_ADDRESS_IDENT
                | POLKADOT_ADDRESS_IDENT
                | ADDRESS_IDENT
NamedAddress ::= IDENTIFIER

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private include ::= <<includeKeyword>>

private invariant ::= <<invariantKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

//SpecDef ::= spec SpecInnerItem { pin = 1 }
SpecDef ::= NameSpecDef | ModuleSpecDef | SchemaSpecDef

NameSpecDef ::= (spec IDENTIFIER) SpecBlock
{
    pin = 1
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveNameSpecDefMixin"
}
ModuleSpecDef ::= (spec module) SpecBlock { pin = 1 }
//SpecDef ::= FunctionSpecDef
//                  | ModuleSpecDef
//                  | StructSpecDef
//                  | SchemaSpecDef
//                  | DefineFunctionSpecDef
//                  | NativeDefineFunctionSpecDef
//{
//    pin = 1
//}

SchemaSpecDef ::= (spec schema) IDENTIFIER TypeParameterList? SpecBlock {
  pin = 1
  implements = [
    "org.move.lang.core.psi.MoveTypeParametersOwner"
    "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
  mixin = "org.move.lang.core.psi.mixins.MoveSchemaDefMixin"
}

//FunctionSpecDef ::= (spec fun) IDENTIFIER SpecBlock
//FunctionSpecDef ::= spec IDENTIFIER SpecBlock
//{
//    pin = 1
//}
//{
//    pin = 1
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.mixins.MoveFunctionSpecMixin"
//}
//StructSpecDef ::= (spec struct) IDENTIFIER SpecBlock
//{
//    pin = 1
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.mixins.MoveStructSpecMixin"
//}
//ModuleSpecDef ::= (spec module) SpecBlock
//{
//    pin = 1
//}

//DefineFunctionSignature ::= define IDENTIFIER
//                                TypeParameterList?
//                                FunctionParameterList ReturnType?
//{
//    pin = 1
//    implements = [
////        "org.move.lang.core.psi.MoveNameIdentifierOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//}

//DefineFunction ::= DefineFunctionSignature SpecBlock
//DefineFunction ::= define IDENTIFIER TypeParameterList?
//                                           FunctionParameterList
//                                           ReturnType?
//                                           SpecBlock
//{
//    pin = 1
////    implements = [
////        "org.move.lang.core.psi.MoveNameIdentifierOwner"
//////        "org.move.lang.core.psi.MoveTypeParametersOwner"
////        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
////    ]
////    mixin = "org.move.lang.core.psi.mixins.MoveDefineFunctionMixin"
//}
//DefineFunctionSpecDef ::= spec DefineFunctionSignature SpecBlock
//DefineFunctionSpec ::= define IDENTIFIER TypeParameterList?
//                                               FunctionParameterList
//                                               ReturnType?
//                                               SpecBlock
//{
//    pin = 1
//    implements = [
////        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//}

//NativeDefineFunction ::= DefineFunctionSignature ';'
//NativeDefineFunction ::= native define IDENTIFIER TypeParameterList?
//                                                   FunctionParameterList
//                                                   ReturnType? ';'
//{
//    pin = 2
//    implements = [
////        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//}
//NativeDefineFunctionSpecDef ::= spec DefineFunctionSignature ';'
//NativeDefineFunctionSpec ::= define IDENTIFIER TypeParameterList?
//                                                FunctionParameterList
//                                                ReturnType? ';'
//{
//    pin = 2
//    implements = [
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
//        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//}

BlockSpecStatement ::= spec SpecBlock ';' {
    pin = 1
//    extends = Statement
}

SpecBlock ::= '{'
                SpecBlockStatement_with_recover*
                SpecBlockFinishingExpr_with_recover?
              '}'
{
    pin = 1
}
//private SpecBlockItems ::= SpecBlockStatement_with_recover*
//                            SpecBlockFinishingExpr_with_recover?
//private ScriptBlockItem_with_recover ::= !('}' | <<eof>>) (ImportStatement | f)
//{
//    pin = 1
//    recoverWhile = ScriptBlockItem_recover
//}
private SpecBlockStatement_with_recover ::= !('}' | <<eof>>) SpecBlockStatement
//{
//    pin = 1
//}
private SpecBlockFinishingExpr_with_recover ::= !('}' | <<eof>>) SpecBlockFinishingExpr
//{
//    pin = 1
//}
private SpecBlockStatement ::= VariableStatement | LocalVariableStatement | GlobalVariableStatement
                               | ImportStatement
                               | InnerSpecFunctionDef | InnerNativeSpecFunctionDef
//                               | NativeFunctionDef
//                               | DefineFunction | DefineFunctionSpecDef
//                               | NativeDefineFunction | NativeDefineFunctionSpecDef
                               | PragmaStatement
                               | AssumeStatement
                               | AssertStatement
                               | AbortsIfStatement
//                               | SucceedsIfStatement
                               | RequiresStatement
                               | EnsuresStatement
                               | ModifiesStatement
                               | IncludeStatement
                               | InvariantStatement
                               | ApplyStatement
                               | EmitsStatement
                               | AggregatePredicateStatement
                               | Statement
private SpecBlockFinishingExpr ::= SpecExpr | AggregateExpr | Expr
//private SpecBlockItems ::= (
//                                Statement
//                                | DefineFunction | DefineFunctionSpec
//                                | NativeDefineFunction | NativeDefineFunctionSpec
//                                | VariableStatement | LocalVariableStatement | GlobalVariableStatement
//                                | PragmaStatement
//                                | AssumeStatement
//                                | AssertStatement
//                                | AbortsIfStatement
//                                | SucceedsIfStatement
//                                | RequiresStatement
//                                | EnsuresStatement
//                                | ModifiesStatement
//                                | IncludeStatement
//                                | InvariantStatement
//                                | ApplyStatement
//                                | AggregatePredicateStatement
//                            )*
//                            (SpecExpr | AggregatePredicate | Expr)?
//{
//    recoverWhile = SpecBlockItems_recover
//}
//private SpecBlockItems_recover ::= !'}'

VariableStatement ::= RefExpr TypeAnnotation ';' { pin = 2 }

LocalVariableStatement ::= local RefExpr TypeAnnotation ';' { pin = 1 }
GlobalVariableStatement ::= global RefExpr TypeAnnotation ';' { pin = 1 }

PragmaStatement ::= pragma <<comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' LiteralExpr)?

SpecExpr ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr
                | RequiresSpecExpr | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr
{
    extends = Expr
}

AssumeStatement ::= AssumeSpecExpr ';'
AssumeSpecExpr ::= assume Predicate { pin = 1 }

AssertStatement ::= AssertSpecExpr ';'
AssertSpecExpr ::= assert Predicate { pin = 1 }

AbortsIfStatement ::= AbortsIfSpecExpr ';'
//noinspection BnfSuspiciousToken
AbortsIfSpecExpr ::= aborts_if Predicate WithExpr? { pin = 1 }
WithExpr ::= with Expr { pin = 1 }

//SucceedsIfStatement ::= SucceedsIfSpecExpr ';'
////noinspection BnfSuspiciousToken
//SucceedsIfSpecExpr ::= succeeds_if Predicate { pin = 1 }

RequiresStatement ::= RequiresSpecExpr ';'
RequiresSpecExpr ::= requires module? Predicate { pin = 1 }

EnsuresStatement ::= EnsuresSpecExpr ';'
EnsuresSpecExpr ::= ensures Predicate { pin = 1 }

ModifiesStatement ::= ModifiesSpecExpr ';'
ModifiesSpecExpr ::= modifies Expr { pin = 1 }

IncludeStatement ::= include SpecVisibility? Expr ';' { pin = 1 }

FunctionPattern ::= (public | internal)? IDENTIFIER TypeArgumentList? { pin = 2 }

InvariantStatement ::= InvariantSpecExpr ';'
InvariantSpecExpr ::= invariant
//                    InvariantModifier?
                    Predicate { pin = 1 }
InvariantModifier ::= pack | unpack | module | update

SpecVisibility ::= '[' <<comma_sep_items SpecVisibilityModifier>> ']' { pin = 1 }
SpecVisibilityModifier ::= global | isolated | deactivated
                                | concrete | abstract
                                | assert | assume

EmitsStatement ::= emits Expr to Expr EmitsCondition? ';' { pin = 1 }
EmitsCondition ::= if Expr { pin = 1 }

ApplyStatement ::= apply ApplySchemaName
                    to <<comma_sep_items FunctionPattern>>
                     ( except <<comma_sep_items FunctionPattern>> )? ';'
{
    pin = 1
}

ApplySchemaName ::= QualPath
                    ('{' <<comma_sep_items ApplySchemaNameAttribute>> '}')?
{
    implements = [
        "org.move.lang.core.psi.MoveQualSchemaReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveApplySchemaNameMixin"
}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

Predicate ::= SpecVisibility? (AggregateExpr | Expr)
//ExprPredicate ::= Expr

//PreconditionStatement ::= PreconditionExpr ';'
//PreconditionExpr ::= Precondition ':' Expr {
//    pin = 2
//}
//Precondition ::= ForAllExistsPrecondition | ExistsPrecondition | ForAllPrecondition

//ForAllExistsPrecondition ::= ForAllPrecondition ':' ExistsPrecondition { pin = 2 }

//private Precondition ::= ((ForAllPrecondition ':' ExistsPrecondition)
//                            | ExistsPrecondition
//                            | ForAllPrecondition) (':' Expr)?

AggregatePredicateStatement ::= AggregateExpr ';'
AggregateExpr ::= QuantifierExpr (':' Expr)?
{
//    pin = AggregatePredicate_body
    rightAssociative = true
}
//private AggregatePredicate_body ::= ':' Expr
//{
//    pin = 1
//    rightAssociative = true
//}
//private AggregatePrecondition ::= ExistsPrecondition
//                                | (ForAllPrecondition (':' AggregatePrecondition)?)

QuantifierWhere ::= where Expr
{
    pin = 1
//    rightAssociative = true
}

private QuantifierExpr ::= ForallQuantifier | ExistsQuantifier
ForallQuantifier ::= forall QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?
ExistsQuantifier ::= exists QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?

QuantifierBindings ::= <<comma_sep_items QuantifierBind>>
QuantifierBind ::= RangeQuantifierBind | TypeQuantifierBind

//ForAllPrecondition ::= forall PreconditionAttribute (',' PreconditionAttribute)* ForAllWhereCondition? {
//    pin = 1
//    extends = Precondition
//}
//ForAllWhereCondition ::= where Expr { pin = 1 }

//ExistsPrecondition ::= exists PreconditionAttribute (',' PreconditionAttribute)* ForAllWhereCondition? {
//    pin = 1
//    extends = Precondition
//}

RangeQuantifierBind ::= IDENTIFIER in RangeExpr {
    pin = 2
    extends = QuantifierBind
}
TypeQuantifierBind ::= IDENTIFIER ':' Type {
    pin = 2
    extends = QuantifierBind
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
