{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"
//
//  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"
    extends(".*Expr")=Expr
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\Z)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'
        LIBRA_ADDRESS='regexp:0x[0-9a-f]{1,40}'
        BOOL_TRUE='regexp:true'
        BOOL_FALSE='regexp:false'
        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        NUMBER='regexp:0|[1-9][0-9]*'
        HEXSTRING='regexp:x"([A-F0-9a-f]+)"'
        BYTESTRING='regexp:b"(.*)"'
//        LOOP_KW='loop'
//        BREAK_KW='break'
//        CONTINUE_KW='continue'
//        LET_KW='let'
//        MUT_KW='mut'
//        IF_KW='if'
//        ELSE_KW='else'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * macro rules are snake_cased: list_item
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= ScriptBlock | AddressBlock*

ScriptBlock ::= script '{' (Import | FunctionDef)* '}' {
    pin = "script"
}
AddressBlock ::= address LIBRA_ADDRESS '{' ModuleDef* '}' {
    pin = "address"
}
ModuleDef ::= module IDENTIFIER '{' ModuleItem* '}' {
    pin = "module"
}
private ModuleItem ::= Import | StructDef | FunctionDef

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
FunctionDef ::= public? fun IDENTIFIER
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    '{' StatementItem* Expr? '}'
{
    pin = "fun"
    name = "function declaration"
}

// trailing comma is allowed
FunctionParams ::= '(' (FunctionParam ','?)* ')' {
    pin = 1
}
FunctionParam ::= IDENTIFIER TypeAscription

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' '('? (TypeReference ','?)* ')'? {
    pin = 1
}
// acquires T, Record
AcquiresType ::= acquires NameExpr (',' NameExpr)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct IDENTIFIER '{' StructFieldDef? (',' StructFieldDef)* '}' {
    pin = "struct"
}
StructFieldDef ::= IDENTIFIER TypeAscription

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction'
Import ::= use LIBRA_ADDRESS '::' IDENTIFIER ('::' IDENTIFIER)? ImportAlias? ';' {
    pin = "use"
}
ImportAlias ::= as IDENTIFIER { pin = 1 }

// Types
TypeAscription ::= ':' TypeReference { pin = 1 }

TypeReference ::= NameExpr | BorrowNameExpr {
    name = "type"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
private StatementItem ::= if_statement | LetDecl | loop_statement
                    | break_statement | continue_statement | abort_statement | return_statement
                    | assignment_statement

loop_statement ::= loop Block ';' {
    pin = "loop"
}
if_statement ::= if '(' Expr ')' Block ElseBlock? ';' {
    pin = "if"
}
ElseBlock ::= else Block { pin = 1 }

Block ::= '{'? StatementItem* Expr? '}'?

Pattern ::= PatternStruct | NameExpr
PatternStruct ::= IDENTIFIER '{' PatternStructField+ '}' { pin = 2 }
PatternStructField ::= IDENTIFIER (':' IDENTIFIER)?

LetDecl ::= let mut? Pattern TypeAscription? LetInitValue? ';' {
    pin = 1
}
LetInitValue ::= '=' Expr { pin = 1 }

continue_statement ::= continue
break_statement ::= break
return_statement ::= return Expr { pin = 1 }
abort_statement ::= abort Expr ';' { pin = 1 }
assignment_statement ::= Pattern '=' Expr ';' { pin = 2 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= logical_or_group
        | logical_and_group
        | logical_eq_group
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | add_group
        | mul_group
        | CastExpr
        | unary_group
        | BorrowExpr
        | primary_group

private mul_group ::= DivExpr | MulExpr | ModExpr
private add_group ::= PlusExpr | MinusExpr
private logical_or_group ::= OrExpr
private logical_and_group ::= AndExpr
private logical_eq_group ::= EqualsExpr | NotEqualsExpr | LessExpr | LessEqualsExpr | GreaterExpr | GreaterEqualsExpr
private unary_group ::= DerefExpr | BangExpr
private primary_group ::= CallExpr |  NameExpr | LiteralExpr | ParensExpr

OrExpr ::= Expr '||' Expr
AndExpr ::= Expr '&&' Expr
EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr
LessExpr ::= Expr '<' Expr
GreaterExpr ::= Expr '>' Expr
LessEqualsExpr ::= Expr '<=' Expr
GreaterEqualsExpr ::= Expr '>=' Expr

BitOrExpr ::= Expr '|' Expr
BitAndExpr ::= Expr '&' Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as TypeReference

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr

ParensExpr ::= '(' Expr ')'
LiteralExpr ::= 'true' | 'false' | NUMBER | HEXSTRING | BYTESTRING

CallExpr ::= NameExpr '(' (Expr ','?)* ')'
BorrowExpr ::= '&' mut? Expr

NameExpr ::= (LIBRA_ADDRESS '::')? (IDENTIFIER '::')? IDENTIFIER
BorrowNameExpr ::= '&' mut? (LIBRA_ADDRESS '::')? (IDENTIFIER '::')? IDENTIFIER