{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MvElement"
    extends="org.move.lang.core.psi.MvElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MvElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"

    extends(".*SpecExpr")=SpecExpr
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends(".*Predicate")=Predicate
    extends("(Lambda|Ref|Path|Tuple)Type")=Type
    extends(".*SpecDef")=SpecDef

    extends(".*SpecStatement")=SpecStatement
    extends(".*Statement")=Statement

    name(".*Expr")="expression"

//    consumeTokenMethod(".*Expr") = "consumeTokenFast"

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
//        EOL_COMMENT='regexp:(//.*\n)|(//.*\R)'
//        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        PLACEHOLDER_ADDRESS_IDENT='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
        PLACEHOLDER_ADDRESS_LITERAL='regexp:@\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'

        ADDRESS_IDENT='regexp:0x[0-9a-fA-F]{1,40}'
        ADDRESS_LITERAL='regexp:@0x[0-9a-fA-F]{1,40}'

        BECH32_ADDRESS_IDENT='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
        BECH32_ADDRESS_LITERAL='regexp:@wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'

        POLKADOT_ADDRESS_IDENT='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'
        POLKADOT_ADDRESS_LITERAL='regexp:@[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'

        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u64)|(u128))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_IDENT='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'

        ADDRESS     = 'address_kw'
        FRIEND     = 'friend_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        POST     = 'post_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        INTERNAL     = 'internal_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'
        AXIOM     = 'axiom_kw'

        PACK     = 'pack_kw'
        UNPACK     = 'unpack_kw'
        UPDATE     = 'update_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        ABORTS_IF     = 'aborts_if_kw'

        CHOOSE     = 'choose_kw'
        MIN     = 'min_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | ScriptDef | AddressDef | ModuleDef)*

Attr ::= '#' '[' <<comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER AttrItemArguments?
AttrItemArguments ::= '(' <<comma_sep_items AttrItemArgument>> ')'
AttrItemArgument ::= IDENTIFIER '=' LitExpr

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

ScriptDef ::= script ScriptBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MvImportStatementsOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvScriptDefMixin"
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | const | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= ImportStatement | ConstDef | FunctionDef

private address ::= <<addressKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MvAddressDefMixin"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= ModuleDef*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= Attr* module (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "module"
    name = "module declaration"
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.MvImportStatementsOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
}
private ModuleBlockItems ::= ModuleItem*
private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | const | struct | spec | friend | Attr
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= ImportStatement | FriendStatement
                            | StructDef | FunctionDef
                            | NativeStructDef | NativeFunctionDef
                            | SpecFunctionDef | SpecNativeFunctionDef | UninterpretedSpecFunctionDef
                            | ConstDef
                            | SpecDef

ConstDef ::= const BindingPat TypeAnnotation Initializer ';'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
SpecFunctionDef ::= (spec FunctionSignature) SpecBlock
SpecNativeFunctionDef ::= (spec native) FunctionSignature ';' { pin = 1 }
UninterpretedSpecFunctionDef ::= spec FunctionSignature ';'

FunctionDefSpecStatement ::= FunctionSignature SpecBlock
NativeFunctionDefSpecStatement ::= native FunctionSignature ';' { pin = 1 }
UninterpretedFunctionDefSpecStatement ::= FunctionSignature ';'

NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';'
{
    pin = 2
    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
NativeStructDef ::= native StructSignature ';'
{
    pin = 2
    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionSignatureWithOptionalVisibility ::= FunctionSignatureVisibility | FunctionSignature
private FunctionSignatureVisibility ::= FunctionVisibilityModifier FunctionSignature { pin = 1 }
FunctionSignature ::= fun IDENTIFIER TypeParameterList?
                          FunctionParameterList
                          ReturnType? AcquiresType?
{
    pin = "fun"
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.MvFunctionSignatureOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MvFunctionSignatureMixin"
    recoverWhile = "FunctionSignature__recover"
}
private FunctionSignature__recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

FunctionDef ::= Attr* FunctionSignatureWithOptionalVisibility CodeBlock
{
    pin = 2
    implements = [
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private friend ::= <<friendKeyword>>
FunctionVisibilityModifier ::= public ('(' (script | friend) ')')?

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')' { pin = 1 }
private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= BindingPat TypeAnnotation { pin = 1 }

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<comma_sep_items PathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructSignature ::= struct IDENTIFIER TypeParameterList? AbilitiesList?
{
    pin = "struct"
    implements = [
        "org.move.lang.core.psi.MvTypeParametersOwner"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MvStructSignatureMixin"
}

StructDef ::= Attr* StructSignature StructFieldsDefBlock
{
    pin = 2
    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

AbilitiesList ::= has <<comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructFieldsDefBlock ::= '{' StructFieldDef_with_recover* '}' { pin = 1 }
private StructFieldDef_with_recover ::= !'}' StructFieldDef (',' | &'}')
{
    pin = 1
    recoverWhile = StructFieldDef_recover
}
private StructFieldDef_recover ::= !('}' | IDENTIFIER)

StructFieldDef ::= IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructFieldDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'

FriendStatement ::= friend FQModuleRef ';' { pin = 1 }

ImportStatement ::= Attr* use (ModuleItemsImport | ModuleImport) ';'
{
    pin = "use"
}
ModuleImport ::= FQModuleRef ImportAlias?
{
    name = "qual path to imported item"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleImportMixin"
}
ModuleItemsImport ::= FQModuleRef '::' (ItemImport | MultiItemImport)
{
    pin = 2
    name = "qual path to imported item"
}

MultiItemImport ::= '{' <<comma_sep_items MultiItemImport_member_with_recovery>> '}'
{
    pin = 1
}
private MultiItemImport_member_with_recovery ::= !('}' | ';' | <<eof>>) ItemImport
{
    pin = 1
}

ItemImport ::= IDENTIFIER ImportAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
        "org.move.lang.core.psi.MvMandatoryReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvItemImportMixin"
}
ImportAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvImportAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type { pin = 1 }

Type ::= RefType | PathType | TupleType | LambdaType

RefType ::= RefTypeStart Type
{
    pin = 1
}
RefTypeStart ::= ('&' mut?)

PathType ::= Path
{
    name = "type"
}

TupleType ::= '(' TupleTypeItem_with_recover* ')' { pin = 1 }
private TupleTypeItem_with_recover ::= !')' Type (',' | &')')
{
    pin = 1
    recoverWhile = TupleTypeItem_recover
}
private TupleTypeItem_recover ::= !(')' | '{' | IDENTIFIER)

LambdaType ::= '|' <<comma_sep_items Type>>? '|' Type { pin = 1 }

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
}
private TypeParameter_with_recover ::= !'>' TypeParameter (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | IDENTIFIER)

TypeParameter ::= phantom? IDENTIFIER TypeParamBound? {
    pin = 2
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MvTypeParameterMixin"
}
TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<comma_sep_items (TypeArgument &(','|'>'))>>? '>'
TypeArgument ::= Type

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvBindingPatMixin"
}

TuplePat ::= '(' <<comma_sep_items Pat>>? ')'

StructPat ::= Path StructPatFieldsBlock
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

StructPatField ::= (BindingPat !':') | (IDENTIFIER StructPatFieldBinding)
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
Statement ::= LetStatement | MacroCallStatement | ExprStatement

LetStatement ::= let Pat TypeAnnotation? Initializer? ';' { pin = 1 }

ExprStatement ::= (ExprStatement_items !('}')) ';' { pin = 1 }
private ExprStatement_items ::= IfExpr
                                | LoopExpr
                                | WhileExpr
                                | Expr
{
    recoverWhile = "ExprStatement_recover"
}
private ExprStatement_recover ::= !(';' | '}' | ExprStatement_first)
private ExprStatement_first ::= let | if | while

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlock_items  '}' { pin = 1 }

private CodeBlock_items ::= ImportStatement*
                            (Statement | SpecBlockSpecStatement)*
                            (Expr | SpecBlockExpr)?
{
    recoverWhile = "CodeBlock_items_recover"
}
private CodeBlock_items_recover ::= !'}'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
        | RangeExpr
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
                    AnnotatedExpr
                    | TupleLitExpr
                    | ParensExpr
                    | StructLitExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
                    | LitExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

MulExpr ::= Expr '*' Expr
DivExpr ::= Expr '/' Expr
PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr
ModExpr ::= Expr '%' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExprItem ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr eqeq_gt Expr
PartialImplyOperatorExpr ::= Expr lt_eqeq_gt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr

CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLitExpr ::= Path StructLitFieldsBlock
StructLitFieldsBlock ::= '{' StructLitField_with_recover* '}' { pin = 1 }

private StructLitField_with_recover ::= !'}' StructLitField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLitField_recover
}
private StructLitField_recover ::= !('}' | IDENTIFIER)

StructLitField ::= IDENTIFIER StructLitFieldAssignment?
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructLitFieldMixin"
}

StructLitFieldAssignment ::= ':' Expr { pin = 1 }

ParensExpr ::= '(' Expr ')'

LambdaExpr ::= '|' <<comma_sep_items IDENTIFIER>> '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLitExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LitExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | PLACEHOLDER_ADDRESS_LITERAL
                | ADDRESS_LITERAL
                | BECH32_ADDRESS_LITERAL
                | POLKADOT_ADDRESS_LITERAL
                | ('@' NamedAddress)

CallExpr ::= (Path &'(') CallArgumentList { pin = 1 }
CallArgumentList ::= '(' <<comma_sep_items (Expr &(','|')'))>>? ')' { pin = 1 }

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr Initializer { rightAssociative = true }
Initializer ::= '=' Expr { pin = 1 }

BorrowExpr ::= '&' mut? Expr
DotExpr ::= Expr '.' StructFieldRef

StructFieldRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.MvStructFieldReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvStructFieldRefMixin"
}

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

RefExpr ::= Path

//private Path ::= QualPath | LocalPath
//fake Path ::= (ModuleRef '::')? IDENTIFIER? TypeArgumentList?
//{
//    implements = ["org.move.lang.core.psi.MvReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MvPathMixin"
//}

//LocalPath ::= IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }
//QualPath ::= ModuleRef '::' IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }

// TODO: add NamedAddress parsing with Move.toml info and switch FQModulePathIdent and ModulePathIdent
Path ::= (ModulePathIdent | FQModulePathIdent | LocalPathIdent) TypeArgumentList?
{
    implements = ["org.move.lang.core.psi.MvPathReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvPathMixin"
}

fake PathIdent ::= ((FQModuleRef | ModuleRef) '::')? IDENTIFIER?

LocalPathIdent ::= IDENTIFIER { elementType = PathIdent }
ModulePathIdent ::= ModuleRef '::' IDENTIFIER
{
    pin = 2
    elementType = PathIdent
}
FQModulePathIdent ::= FQModuleRef '::' IDENTIFIER
{
    pin = 1
    elementType = PathIdent
}

ModuleRef ::= IDENTIFIER | FQModuleRef
{
    implements = ["org.move.lang.core.psi.MvReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvModuleRefMixin"
}

FQModuleRef ::= AddressRef '::' IDENTIFIER
{
    pin = 2
    extends = ModuleRef
    implements = [
        "org.move.lang.core.psi.MvFQModuleReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFQModuleRefMixin"
}

AddressRef ::= NamedAddress
                | PLACEHOLDER_ADDRESS_IDENT
                | BECH32_ADDRESS_IDENT
                | POLKADOT_ADDRESS_IDENT
                | ADDRESS_IDENT
NamedAddress ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.NamedAddressReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvNamedAddressMixin"
}

/// Macros
MacroCallStatement ::= IDENTIFIER '!' CallArgumentList ';' { pin = 2 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private include ::= <<includeKeyword>>
private choose ::= <<chooseKeyword>>
private min ::= <<minKeyword>>

private invariant ::= <<invariantKeyword>>
private axiom ::= <<axiomKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

SpecDef ::= NameSpecDef | ModuleSpecDef | SchemaSpecDef

NameSpecDef ::= (spec IDENTIFIER) SpecBlock
//{
//    pin = 1
//    implements = ["org.move.lang.core.psi.MvReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MvNameSpecDefMixin"
//}
ModuleSpecDef ::= (spec module) SpecBlock { pin = 1 }

SchemaSpecDef ::= (spec schema) IDENTIFIER TypeParameterList? SpecBlock {
  pin = 1
  implements = [
    "org.move.lang.core.psi.MvTypeParametersOwner"
    "org.move.lang.core.psi.MvNameIdentifierOwner" ]
  mixin = "org.move.lang.core.psi.mixins.MvSchemaDefMixin"
}

SpecBlockExpr ::= spec SpecBlock
SpecBlockSpecStatement ::= SpecBlockExpr ';'

SpecBlock ::= '{'
                SpecBlockStatement_with_recover*
                SpecBlockFinishingExpr_with_recover?
              '}'
{
    pin = 1
}

private SpecBlockStatement_with_recover ::= !('}' | <<eof>>) SpecStatement
private SpecBlockFinishingExpr_with_recover ::= !('}' | <<eof>>) SpecBlockFinishingExpr

SpecStatement ::= ImportStatement
                               | VariableSpecStatement
                               | LocalVariableSpecStatement
                               | GlobalVariableSpecStatement
                               | FunctionDefSpecStatement
                               | NativeFunctionDefSpecStatement
                               | UninterpretedFunctionDefSpecStatement
                               | PragmaSpecStatement
                               | AssumeSpecStatement
                               | AssertSpecStatement
                               | AbortsIfSpecStatement
                               | RequiresSpecStatement
                               | EnsuresSpecStatement
                               | ModifiesSpecStatement
                               | IncludeSpecStatement
                               | InvariantSpecStatement
                               | AxiomSpecStatement
                               | ApplySpecStatement
                               | EmitsSpecStatement
                               | AggregatePredicateSpecStatement
                               | SpecBlockSpecStatement
                               | LetSpecStatement
                               | ChooseSpecStatement
                               | Statement
private SpecBlockFinishingExpr ::= SpecExpr | AggregateExpr | Expr

VariableSpecStatement ::= IDENTIFIER TypeAnnotation ';' { pin = 2 }

LocalVariableSpecStatement ::= local IDENTIFIER TypeAnnotation ';' { pin = 1 }
GlobalVariableSpecStatement ::= global IDENTIFIER TypeAnnotation ';' { pin = 1 }

private post ::= <<postKeyword>>
LetSpecStatement ::= (let post?) Pat TypeAnnotation? Initializer? ';' { pin = 1 }
PragmaSpecStatement ::= pragma <<comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' Expr)?

SpecExpr ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr
                | RequiresSpecExpr | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr | AxiomSpecExpr
{
    extends = Expr
}

AssumeSpecStatement ::= AssumeSpecExpr ';'
AssumeSpecExpr ::= assume Predicate { pin = 1 }

AssertSpecStatement ::= AssertSpecExpr ';'
AssertSpecExpr ::= assert Predicate { pin = 1 }

AbortsIfSpecStatement ::= AbortsIfSpecExpr ';'
//noinspection BnfSuspiciousToken
AbortsIfSpecExpr ::= aborts_if Predicate WithExpr? { pin = 1 }
WithExpr ::= with Expr { pin = 1 }

RequiresSpecStatement ::= RequiresSpecExpr ';'
RequiresSpecExpr ::= requires module? Predicate { pin = 1 }

EnsuresSpecStatement ::= EnsuresSpecExpr ';'
EnsuresSpecExpr ::= ensures Predicate { pin = 1 }

ModifiesSpecStatement ::= ModifiesSpecExpr ';'
ModifiesSpecExpr ::= modifies Expr { pin = 1 }

IncludeSpecStatement ::= include SpecVisibility? Expr ';' { pin = 1 }

private PatternVis ::= <<patternVisibility>>
private PatternIdent ::= <<patternIdent>>

//fake FunctionPatternIdent ::= ('*' | IDENTIFIER)+
FunctionPattern ::= PatternVis? PatternIdent TypeArgumentList? { pin = 2 }
//FunctionPattern ::= (public | internal)? IDENTIFIER TypeArgumentList? { pin = 2 }

private InvariantModifier ::= <<invariantModifierKeyword>>
InvariantSpecStatement ::= InvariantSpecExpr ';'
InvariantSpecExpr ::= invariant InvariantModifier? TypeParameterList? Predicate { pin = 1 }

AxiomSpecStatement ::= AxiomSpecExpr ';'
AxiomSpecExpr ::= axiom TypeParameterList? Predicate { pin = 1 }
//InvariantModifier ::= pack | unpack | module | update

SpecVisibility ::= '[' <<comma_sep_items SpecVisibilityModifier>> ']' { pin = 1 }

SpecVisibilityModifier ::= IDENTIFIER
//SpecVisibilityModifier ::= global | isolated | deactivated
//                                | concrete | abstract
//                                | assert | assume

EmitsSpecStatement ::= emits Expr to Expr EmitsCondition? ';' { pin = 1 }
EmitsCondition ::= if Expr { pin = 1 }

ApplySpecStatement ::= apply ApplySchemaName
                    to <<comma_sep_items FunctionPattern>>
                     ( except <<comma_sep_items FunctionPattern>> )? ';'
{
    pin = 1
}

ApplySchemaName ::= Path
                    ('{' <<comma_sep_items ApplySchemaNameAttribute>> '}')?
//{
//    implements = [
//        "org.move.lang.core.psi.MvQualSchemaReferenceElement"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MvApplySchemaNameMixin"
//}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

Predicate ::= SpecVisibility? (AggregateExpr | Expr)

AggregatePredicateSpecStatement ::= AggregateExpr ';'
AggregateExpr ::= QuantifierExpr (':' Expr)?
{
    rightAssociative = true
}

QuantifierWhere ::= where Expr
{
    pin = 1
//    rightAssociative = true
}

private QuantifierExpr ::= ForallQuantifier | ExistsQuantifier
ForallQuantifier ::= forall QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?
ExistsQuantifier ::= exists QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?

ChooseSpecStatement ::= choose min? QuantifierBindings
                        (QuantifierWhere)?
                        (':' QuantifierExpr)? ';'
{
    pin = 1
}

QuantifierBindings ::= <<comma_sep_items QuantifierBind>>
QuantifierBind ::= RangeQuantifierBind | TypeQuantifierBind

RangeQuantifierBind ::= IDENTIFIER in RangeExpr {
    pin = 2
    extends = QuantifierBind
}
TypeQuantifierBind ::= IDENTIFIER ':' Type {
    pin = 2
    extends = QuantifierBind
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
