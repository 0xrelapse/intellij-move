{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Move"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MoveElement"
    extends="org.move.lang.core.psi.impl.MoveElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MoveElementType"
    tokenTypeClass="org.move.lang.core.MoveTokenType"

    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends(".*Predicate")=Predicate

    name(".*Expr")="expression"

//    consumeTokenMethod(".*Expr") = "consumeTokenFast"

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]*)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_NAME='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnuMoveariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (ScriptDef | AddressDef | ModuleDef)*


ScriptDef ::= script ScriptBlock {
    pin = 1
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= (ImportStatement | FunctionDef)* { recoverWhile = "ScriptBlockItems_recover" }
private ScriptBlockItems_recover ::= !'}'

AddressDef ::= address ADDRESS_LITERAL AddressBlock {
    pin = 1
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= ModuleDef*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= module IDENTIFIER ModuleBlock
{
    pin = 1
    name = "module declaration"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveModuleDefMixin"
}
ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
}
private ModuleBlockItems ::= ModuleItem*
{
    recoverWhile = "ModuleBlockItems_recover"
}
private ModuleBlockItems_recover ::= !'}'

private ModuleItem ::= ImportStatement | StructDef | NativeStructDef |
                            FunctionDef | NativeFunctionDef | ConstDef | SpecItem

ConstDef ::= const IDENTIFIER TypeAscription ConstDef_init ';'
{
    pin = 1
    implements = ["org.move.lang.core.psi.MoveNameIdentifierOwner"]
    mixin = "org.move.lang.core.psi.mixins.MoveConstDefMixin"
}
private ConstDef_init ::= '=' Expr
{
    recoverWhile = "ConstDef_init_recover"
}
private ConstDef_init_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
NativeFunctionDef ::= native public? fun IDENTIFIER TypeParameterList?
                         FunctionParameterList
                         ReturnType?
                         AcquiresType? ';'
{
    pin = "fun"
    name = "native function"
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveNativeFunctionDefMixin"
}

FunctionDef ::= public? fun IDENTIFIER TypeParameterList?
                    FunctionParameterList
                    ReturnType?
                    AcquiresType?
                    CodeBlock
{
    pin = "fun"
    name = "function"
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionDefMixin"
}

FunctionParameterList ::= '(' <<comma_sep_items FunctionParameter>>? ')'
{
    pin = 1
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParameterListMixin"
}
//private FunctionParameterList_body ::= <<comma_separated_list FunctionParameter>> {
//    recoverWhile = "FunctionParameterList_body_recover"
//}
//private FunctionParameterList_body_recover ::= !')'

FunctionParameter ::= IDENTIFIER TypeAscription
{
    pin = 1
    recoverWhile = "FunctionParameter_recover"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParameterMixin"
}
private FunctionParameter_recover ::= !(','|')')

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' Type { pin = 1 }

// acquires T, Record
AcquiresType ::= acquires <<comma_sep_items QualifiedPathType>> { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
NativeStructDef ::= native resource? struct IDENTIFIER TypeParameterList? ';'
{
    pin = "struct"
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveNativeStructDefMixin"
}

StructDef ::= resource? struct IDENTIFIER
                TypeParameterList?
                StructFieldsDefBlock
{
    pin = "struct"
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructDefMixin"
}
StructFieldsDefBlock ::= '{' <<comma_sep_items StructFieldDef>>? '}' { pin = 1 }
//private StructFieldsBlock_body ::= <<comma_sep_list StructFieldDef>>?
{
//    recoverWhile = "StructFieldsBlock_body_recover"
}
//private StructFieldsBlock_body_recover ::= !'}'

StructFieldDef ::= IDENTIFIER StructFieldDef_type { pin = 1 }
private StructFieldDef_type ::= TypeAscription
{
    recoverWhile = "StructFieldDef_type_recover"
}
private StructFieldDef_type_recover ::= !(','|'}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'
ImportStatement ::= use AddressRef '::' Import ';' { pin = 1 }

Import ::= ItemImport | ModuleImport
ModuleImport ::= ModuleRef ImportAlias?
{
    extends = Import
}
ItemImport ::= ModuleRef '::' (ImportedItem | ImportedItem_multiple)
{
    pin = 2
    extends = Import
}
private ImportedItem_multiple ::= '{' <<comma_sep_items ImportedItem>> '}'  { pin = 1 }

ImportedItem ::= IDENTIFIER ImportAlias?
{
    pin = 1
//    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
//    mixin = "org.move.lang.core.psi.mixins.MoveImportMixin"
}
ImportAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveImportAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
private TypeAscription ::= ':' Type { pin = 1 }

Type ::= QualifiedPathType | TupleType | LambdaType

QualifiedPathType ::= ('&' mut?)? QualifiedPath
{
    name = "type"
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveQualifiedPathTypeMixin"
}

TupleType ::= '(' <<comma_sep_items Type>>? ')' { pin = 1 }

LambdaType ::= '|' <<comma_sep_items Type>>? '|' Type { pin = 1 }

TypeParameterList ::= '<' <<comma_sep_items TypeParameter>>? '>'
TypeParameter ::= IDENTIFIER TypeParamBound? {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveTypeParameterMixin"
}
TypeParamBound ::= ':' (copyable | resource)

TypeArgumentList ::= '<' <<comma_sep_items (QualifiedPathType &(','|'>'))>>? '>'
//private TypeArgument ::= TypeRef &(','|'>')
//{
//    recoverWhile = "TypeArgument_recover"
//}
//private TypeArgument_recover ::= !(','|'>')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveBindingPatMixin"
}

TuplePat ::= '(' <<comma_sep_items Pat>>? ')'
//private TuplePat_body ::= (<<comma_sep_list Pat>>)? {
//    recoverWhile = "TuplePat_body_recover"
//}
//private TuplePat_body_recover ::= !(')'|'=')

StructPat ::= QualifiedPath StructPatFieldsBlock {
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructPatMixin"
}
StructPatFieldsBlock ::= '{' (<<comma_sep_items StructPatField>>)? '}' { pin = 1 }

StructPatField ::= IDENTIFIER (':' Pat)? {
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructPatFieldMixin"
}
//StructPatFieldBinding ::= ':' Pat { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
//private Statement ::= IfStatement | LoopStatement | WhileStatement
//                            | LetStatement | AssignmentStatement
//                            | ExprStatement
Statement ::= StatementExpr ';'
private StatementExpr ::= IfExpr
                            | LoopExpr
                            | WhileExpr
                            | LetExpr
//                            | AssignmentExpr
                            | Expr
{
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= '!;'

//InlineSpecBlock ::= spec SpecBlock { pin = 1 }

//IfStatement ::= IfExpr ';'
//LoopStatement ::= LoopExpr ';'
//WhileStatement ::= WhileExpr ';'

//private StatementBody ::= IfExpr

//LetStatement ::= LetStatementInner ';'
//private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
//private LetStatementInner_recover ::= !';'

//AssignmentStatement ::= AssignmentExpr ';'
//ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= '{' CodeBlockItems '}'
CodeBlock ::= '{' CodeBlockItems  '}'

private CodeBlockItems ::= ImportStatement* (Statement | BlockSpecStatement)* Expr?
//{
//    recoverWhile = "CodeBlock_body_recover"
//}
//private CodeBlock_body_recover ::= !'}'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExprItem
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

private AssignmentExprItem ::= LetExpr | AssignmentExpr
private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
//IfExpr
//                    | LoopExpr
//                    | WhileExpr
//                    | LetExpr
                    AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
//                    | AssignmentExpr
                    | StructLiteralExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
                    | RangeExpr
                    | LiteralExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExprItem ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr eqeq_gt Expr
PartialImplyOperatorExpr ::= Expr lt_eqeq_gt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= QualifiedPath StructLiteralFieldsBlock
{
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructLiteralExprMixin"
}
StructLiteralFieldsBlock ::= '{' <<comma_sep_items StructLiteralExprField>>? '}' { pin = 1 }
//private StructLiteralFieldsBlock_body ::= (StructLiteralExprField ','?)*
//{
//    recoverWhile = "StructLiteralFieldsBlock_body_recover"
//}
//private StructLiteralFieldsBlock_body_recover ::= !'}'

StructLiteralExprField ::= IDENTIFIER (':' Expr)? {
    pin = 1
    recoverWhile = StructLiteralExprField_recover
}
private StructLiteralExprField_recover ::= !(','|'}')

ParensExpr ::= '(' Expr ')'
//private ParensExpr_body ::= Expr { recoverWhile = "ParensExpr_body_recover" }
//private ParensExpr_body_recover ::= !(':'|')'|',')
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

//TupleLiteralExpr ::= '('
//TupleLiteralExpr ::= '(' TupleLiteralExpr? ')' { pin = 2 }
//private TupleLiteralExpr_body ::= (Expr ',' (Expr ','?)*)?
LambdaExpr ::= '|' <<comma_sep_items IDENTIFIER>> '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLiteralExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL

CallExpr ::= QualifiedPath CallArguments {
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveCallExprMixin"
}

CallArguments ::= '(' <<comma_sep_items Expr>>? ')' { pin = 1 }
//private CallArgument ::= Expr {
//    recoverWhile = "CallArgument_recover"
//}
//private CallArgument_recover ::= !(','|')')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr '=' Expr { rightAssociative = true }

LetExpr ::= let Pat TypeAscription? Initializer? {
    pin = 1
    mixin = "org.move.lang.core.psi.mixins.MoveLetExprMixin"
}
private Initializer ::= '=' Expr {
    pin = 1
//    recoverWhile = "Initializer_recover"
}
//private Initializer_recover ::= !(';'|'}'|')')

BorrowExpr ::= '&' mut? Expr
DotExpr ::= Expr '.' IDENTIFIER
IndexExpr ::= Expr '[' Expr ']' { rightAssociative = true }
RefExpr ::= QualifiedPath {
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveRefExprMixin"
}

QualifiedPath ::= (AddressRef '::')? (ModuleRef '::')? IDENTIFIER TypeArgumentList?
{
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveQualifiedPathMixin"
}
AddressRef ::= ADDRESS_LITERAL
ModuleRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveModuleRefMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
//SpecDef ::= spec SpecInnerItem { pin = 1 }
private SpecItem ::= FunctionSpec
                          | ModuleSpec
                          | StructSpec
                          | SchemaDef
                          | SpecDefineFunction
                          | NativeDefineFunction

SchemaDef ::= spec schema IDENTIFIER TypeParameterList? SpecBlock {
  pin = 2
  implements = [
    "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
    "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
  mixin = "org.move.lang.core.psi.mixins.MoveSchemaDefMixin"
}

FunctionSpec ::= spec fun IDENTIFIER SpecBlock {
    pin = 2
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionSpecMixin"
}
StructSpec ::= spec struct IDENTIFIER SpecBlock {
    pin = 2
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructSpecMixin"
}
ModuleSpec ::= spec module SpecBlock { pin = 2 }

DefineFunction ::= define IDENTIFIER TypeParameterList?
                                                   FunctionParameterList
                                                   ReturnType?
                                                   SpecBlock
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
    ]
}
SpecDefineFunction ::= spec define IDENTIFIER TypeParameterList?
                                                   FunctionParameterList
                                                   ReturnType?
                                                   SpecBlock
{
    pin = 2
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
    ]
}

NativeDefineFunction ::= native define IDENTIFIER TypeParameterList?
                                                   FunctionParameterList
                                                   ReturnType? ';'
{
    pin = 2
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
    ]
}
SpecNativeDefineFunction ::= spec native define IDENTIFIER TypeParameterList?
                                                   FunctionParameterList
                                                   ReturnType? ';'
{
    pin = 3
    implements = [
        "org.move.lang.core.psi.ext.MoveTypeParametersOwner"
    ]
}

BlockSpecStatement ::= spec SpecBlock ';' {
    pin = 1
//    extends = Statement
}

SpecBlock ::= '{' SpecBlockItems '}' { pin = 1 }
private SpecBlockItems ::= (
                                Statement
                                | DefineFunction | SpecDefineFunction
                                | NativeDefineFunction | SpecNativeDefineFunction
                                | VariableStatement | LocalVariableStatement | GlobalVariableStatement
                                | PragmaStatement
                                | AssumeStatement
                                | AssertStatement
                                | AbortsIfStatement
                                | SucceedsIfStatement
                                | RequiresStatement
                                | EnsuresStatement
                                | ModifiesStatement
                                | IncludeStatement
                                | InvariantStatement
                                | ApplyStatement
                                | AggregatePredicateStatement
                            )*
                            (SpecExpr | AggregatePredicate | Expr)?
{
    recoverWhile = SpecBlock_body_recover
}
private SpecBlock_body_recover ::= !'}'

VariableStatement ::= RefExpr ':' Type ';'
LocalVariableStatement ::= local RefExpr ':' Type ';' { pin = 1 }
GlobalVariableStatement ::= global RefExpr ':' Type ';' { pin = 1 }

PragmaStatement ::= pragma <<comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' LiteralExpr)?

SpecExpr ::= AssumeExpr | AssertExpr | AbortsIfExpr | SucceedsIfExpr | RequiresExpr | EnsuresExpr | ModifiesExpr
                | InvariantExpr
{
    extends = Expr
}

AssumeStatement ::= AssumeExpr ';'
AssumeExpr ::= assume Predicate { pin = 1 }

AssertStatement ::= AssertExpr ';'
AssertExpr ::= assert Predicate { pin = 1 }

AbortsIfStatement ::= AbortsIfExpr ';'
//noinspection BnfSuspiciousToken
AbortsIfExpr ::= aborts_if Predicate (with Expr)? { pin = 1 }

SucceedsIfStatement ::= SucceedsIfExpr ';'
//noinspection BnfSuspiciousToken
SucceedsIfExpr ::= succeeds_if Predicate { pin = 1 }

RequiresStatement ::= RequiresExpr ';'
RequiresExpr ::= requires module? Predicate { pin = 1 }

EnsuresStatement ::= EnsuresExpr ';'
EnsuresExpr ::= ensures Predicate { pin = 1 }

ModifiesStatement ::= ModifiesExpr ';'
ModifiesExpr ::= modifies Expr { pin = 1 }

IncludeStatement ::= include Expr ';' { pin = 1 }

FunctionPattern ::= (public | internal)? (FUNCTION_PATTERN_NAME | IDENTIFIER) TypeArgumentList? { pin = 2 }

InvariantStatement ::= InvariantExpr ';'
InvariantExpr ::= invariant
                    InvariantModifier?
                    InvariantVisibility?
                    Predicate { pin = 1 }
InvariantModifier ::= pack | unpack | module | update
InvariantVisibility ::= '[' <<comma_sep_items InvariantVisibilityModifier>> ']' { pin = 1 }
InvariantVisibilityModifier ::= global | isolated | deactivated

ApplyStatement ::= apply ApplySchemaName
                    to <<comma_sep_items FunctionPattern>>
                     ( except <<comma_sep_items FunctionPattern>> )? ';'
{
    pin = 1
}

ApplySchemaName ::= QualifiedPath
                    ('{' <<comma_sep_items ApplySchemaNameAttribute>> '}')?
{
    implements = [ "org.move.lang.core.psi.MoveSchemaReferenceElement" ]
    mixin = "org.move.lang.core.psi.mixins.MoveApplySchemaNameMixin"
}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

Predicate ::= AggregatePredicate | ExprPredicate
ExprPredicate ::= Expr

//PreconditionStatement ::= PreconditionExpr ';'
//PreconditionExpr ::= Precondition ':' Expr {
//    pin = 2
//}
//Precondition ::= ForAllExistsPrecondition | ExistsPrecondition | ForAllPrecondition

//ForAllExistsPrecondition ::= ForAllPrecondition ':' ExistsPrecondition { pin = 2 }

//private Precondition ::= ((ForAllPrecondition ':' ExistsPrecondition)
//                            | ExistsPrecondition
//                            | ForAllPrecondition) (':' Expr)?

AggregatePredicateStatement ::= AggregatePredicate ';'
AggregatePredicate ::= AggregatePrecondition AggregateWhereExpr? (':' Expr)?
{
//    pin = AggregatePredicate_body
    rightAssociative = true
}
//private AggregatePredicate_body ::= ':' Expr
//{
//    pin = 1
//    rightAssociative = true
//}
private AggregatePrecondition ::= ExistsPrecondition | (ForAllPrecondition (':' ExistsPrecondition)?)

AggregateWhereExpr ::= where Expr
{
    pin = 1
    rightAssociative = true
}
//private AggregateWhereExpr_body ::= Expr { recoverWhile = AggregateWhereExpr_body_recover }
//private AggregateWhereExpr_body_recover ::= !':'

ForAllPrecondition ::= forall PreconditionAttributeList { pin = 1 }
ExistsPrecondition ::= exists PreconditionAttributeList { pin = 1 }

PreconditionAttributeList ::= <<comma_sep_items PreconditionAttribute>>
PreconditionAttribute ::= ContainsPreconditionAttribute | TypePreconditionAttribute

//ForAllPrecondition ::= forall PreconditionAttribute (',' PreconditionAttribute)* ForAllWhereCondition? {
//    pin = 1
//    extends = Precondition
//}
//ForAllWhereCondition ::= where Expr { pin = 1 }

//ExistsPrecondition ::= exists PreconditionAttribute (',' PreconditionAttribute)* ForAllWhereCondition? {
//    pin = 1
//    extends = Precondition
//}

ContainsPreconditionAttribute ::= IDENTIFIER in RangeExpr {
    pin = 2
    extends = PreconditionAttribute
}
TypePreconditionAttribute ::= IDENTIFIER ':' Type {
    pin = 2
    extends = PreconditionAttribute
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
