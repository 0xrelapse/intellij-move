{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Move"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MoveElement"
    extends="org.move.lang.core.psi.impl.MoveElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MoveElementType"
    tokenTypeClass="org.move.lang.core.MoveTokenType"
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]*)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnuMoveariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= (ScriptDef | AddressDef | ModuleDef)*

ScriptDef ::= script ScriptBlock {
    pin = 1
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= (ImportStatement | FunctionDef)* { recoverWhile = "ScriptBlockItems_recover" }
private ScriptBlockItems_recover ::= !'}'

AddressDef ::= address ADDRESS_LITERAL AddressBlock {
    pin = 1
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1}
private AddressBlockItems ::= ModuleDef* { recoverWhile = AddressBlockItems_recover }
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= module identifier ModuleBlock {
    pin = 1
    name = "module declaration"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveModuleDefImplMixin"
}
ModuleBlock ::= '{' ModuleBlockItems '}' { pin = 1 }
private ModuleBlockItems ::= ModuleItem* { recoverWhile = "ModuleBlockItems_recover" }
private ModuleBlockItems_recover ::= !'}'

private ModuleItem ::= ImportStatement | StructDef | FunctionDef | NativeFunctionDef | ConstDef

ConstDef ::= const ConstDefInner ';' {
    pin = 1
}
private ConstDefInner ::= identifier TypeAscription '=' Expr {
    recoverWhile = "ConstDefInner_recover"
}
private ConstDefInner_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
NativeFunctionDef ::= native public? fun identifier TypeParameterList?
                     FunctionParams
                     ReturnType?
                     AcquiresType? ';'
{
    pin = 1
    name = "native function"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveNativeFunctionDefImplMixin"
}

FunctionDef ::= public? fun identifier TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    CodeBlock
{
    pin = "fun"
    name = "function"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionDefImplMixin"
}

// trailing comma is allowed
FunctionParams ::= '(' FunctionParamsBody ')' { pin = 1 }
private FunctionParamsBody ::= (FunctionParam ','?)* {
    recoverWhile = "FunctionParamsBody_recover"
}
private FunctionParamsBody_recover ::= !')'

FunctionParam ::= identifier TypeAscription {
    pin = 1
    recoverWhile = "FunctionParams_recover"
}
private FunctionParams_recover ::= !(','|')')

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' Type {
    pin = 1
}
// acquires T, Record
AcquiresType ::= acquires PathExpr (',' PathExpr)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct identifier
                TypeParameterList?
                StructFields
{
    pin = "struct"
}
StructFields ::= '{' StructFields_body '}' { pin = 1 }
private StructFields_body ::= (StructFieldDef (',' StructFieldDef)* ','?)?
{
    recoverWhile = "StructFields_body_recover"
}
private StructFields_body_recover ::= !'}'

StructFieldDef ::= identifier StructFieldDef_type { pin = 1 }
private StructFieldDef_type ::= TypeAscription {
    recoverWhile = "StructFieldDef_type_recover"
}
private StructFieldDef_type_recover ::= !(','|'}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'
ImportStatement ::= use ADDRESS_LITERAL '::' (ModuleMemberImport | ModuleImport) ';' { pin = 1 }

ModuleImport ::= Import
ModuleMemberImport ::= identifier '::' (Import | MultipleImport) { pin = 2 }

private MultipleImport ::= '{' Import MultipleImportSeq ','? '}' { pin = 1 }
private MultipleImportSeq ::= (',' Import)* {
    recoverWhile = "MultipleImportSeq_recover"
}
private MultipleImportSeq_recover ::= !((','? '}') | ';')

Import ::= identifier ImportAlias? { pin = 1 }
ImportAlias ::= as identifier { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
private TypeAscription ::= ':' Type { pin = 1 }

Type ::= TupleType | TypeReference
TypeReference ::= ('&' mut?)? (address | PathExpr) {
    name = "type"
}
TupleType ::= '(' (Type ','?)* ','? ')' { pin = 1 }

TypeParameterList ::= '<' (TypeParameter (',' TypeParameter)* ','?)? '>'
TypeParameter ::= identifier TypeParamBound?
TypeParamBound ::= ':' (copyable | resource)

TypeArgumentList ::= '<' (TypeArgument (',' TypeArgument)* ','?)? '>'
private TypeArgument ::= TypeReference {
    recoverWhile = "TypeArgument_recover"
}
private TypeArgument_recover ::= !(','|'>')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= identifier '.' identifier { pin = 2 }

BindingPat ::= identifier {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveBindingPatImplMixin"
}

TuplePat ::= '(' TuplePat_body ')'
private TuplePat_body ::= (Pat (',' Pat)*)? {
    recoverWhile = "TuplePat_body_recover"
}
private TuplePat_body_recover ::= !(')'|'=')

StructPat ::= PathExpr '{' (StructPatField ','?)* '}' { pin = 2 }
StructPatField ::= identifier StructPatFieldBinding?
StructPatFieldBinding ::= ':' (StructPat | BindingPat) { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
//private Statement ::= IfStatement | LoopStatement | WhileStatement
//                            | LetStatement | AssignmentStatement
//                            | ExprStatement
Statement ::= StatementExpr ';'
private StatementExpr ::= IfExpr | LoopExpr | WhileExpr
                        | LetExpr | AssignmentExpr | Expr {
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= '!;'

//IfStatement ::= IfExpr ';'
//LoopStatement ::= LoopExpr ';'
//WhileStatement ::= WhileExpr ';'

//private StatementBody ::= IfExpr

//LetStatement ::= LetStatementInner ';'
//private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
//private LetStatementInner_recover ::= !';'

//AssignmentStatement ::= AssignmentExpr ';'
//ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
InlineBlock ::= Expr
CodeBlock ::= '{' Block_body '}' {
    pin = 1
}
private AnyBlock ::= CodeBlock | InlineBlock

BlockExpr ::= '{' Block_body '}' { pin = 1 }

private Block_body ::= (Statement)* Expr? { recoverWhile = "Block_body_recover" }
private Block_body_recover ::= !'}'

//Block ::= '{' (StatementItem ';')* Expr? '}' {
//    pin = 1
//    name = "block"
//}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    name = "expr"
}

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

private AssignmentExprItem ::= AssignmentExpr | LetExpr
private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
//IfExpr
//                    | LoopExpr
//                    | WhileExpr
//                    | LetExpr
                    AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
//                    | AssignmentExpr
                    | StructLiteralExpr
                    | DotExpr
                    | CallExpr
                    | PathExpr
                    | LiteralExpr
                    | BlockExpr

EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!ltlt '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= PathExpr '{' StructLiteralExpr_body '}'
{
    pin = 2
}
private StructLiteralExpr_body ::= (StructLiteralExprField ','?)*
{
    recoverWhile = "StructLiteralExpr_body_recover"
}
private StructLiteralExpr_body_recover ::= !'}'

StructLiteralExprField ::= identifier (':' Expr)? {
    pin = 1
    recoverWhile = StructLiteralExprField_recover
}
private StructLiteralExprField_recover ::= !(','|'}')

ParensExpr ::= '(' Expr ')'
//private ParensExpr_body ::= Expr { recoverWhile = "ParensExpr_body_recover" }
//private ParensExpr_body_recover ::= !(':'|')'|',')
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

//TupleLiteralExpr ::= '('
//TupleLiteralExpr ::= '(' TupleLiteralExpr? ')' { pin = 2 }
//private TupleLiteralExpr_body ::= (Expr ',' (Expr ','?)*)?

TupleLiteralExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' (Expr ','?)* ')' { pin = 3 }

LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL

CallExpr ::= PathExpr CallArguments

CallArguments ::= '(' (CallArgument (',' CallArgument)* ','?)? ')' { pin = 1 }
private CallArgument ::= Expr {
    recoverWhile = "CallArgument_recover"
}
private CallArgument_recover ::= !(','|')')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Pat '=' Expr
LetExpr ::= let Pat TypeAscription? Initializer? {
    pin = 1
}
private Initializer ::= '=' Expr {
    pin = 1
//    recoverWhile = "Initializer_recover"
}
//private Initializer_recover ::= !(';'|'}'|')')

BorrowExpr ::= '&' mut? Expr { pin = 1 }
DotExpr ::= Expr '.' identifier

PathExpr ::= (ADDRESS_LITERAL '::')? (identifier '::')? identifier TypeArgumentList?

//PathExpr ::= (ADDRESS_LITERAL '::')? (identifier '::')? identifier TypeArguments? {
//    implements = ["org.move.lang.core.psi.mixins.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.mixins.MovePathExprImplMixin"
//}

//Initializer ::= '=' Expr { pin = 1 }

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>

