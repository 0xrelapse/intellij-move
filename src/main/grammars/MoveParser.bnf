{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"
//
//  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"
    extends(".*Expr")=Expr
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\Z)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:0|[1-9][0-9]*((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]+)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
//        LOOP_KW='loop'
//        BREAK_KW='break'
//        CONTINUE_KW='continue'
//        LET_KW='let'
//        MUT_KW='mut'
//        IF_KW='if'
//        ELSE_KW='else'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * macro rules are snake_cased: list_item
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= ScriptBlock | (AddressBlock | ModuleDef)*

ScriptBlock ::= script '{' (Import | FunctionDef)* '}' {
    pin = "script"
}
AddressBlock ::= address ADDRESS_LITERAL '{' ModuleDef* '}' {
    pin = "address"
}
ModuleDef ::= module IDENTIFIER '{' ModuleItem* '}' {
    pin = "module"
}
private ModuleItem ::= Import | StructDef | FunctionDef

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
FunctionDef ::= public? fun IDENTIFIER TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    Block
{
    pin = "fun"
    name = "function declaration"
}

// trailing comma is allowed
FunctionParams ::= '(' (FunctionParam ','?)* ')' {
    pin = 1
}
FunctionParam ::= IDENTIFIER TypeAscription

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' (TypeReference | TupleType) {
    pin = 1
}
TupleType ::= '(' (TypeReference ','?)* ','? ')' { pin = 1 }
// acquires T, Record
AcquiresType ::= acquires PathExpr (',' PathExpr)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct IDENTIFIER TypeParameterList?
                '{'
                StructFieldDef? (',' StructFieldDef)*
                '}'
{
    pin = "struct"
}

StructFieldDef ::= IDENTIFIER TypeAscription

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction'
Import ::= use ADDRESS_LITERAL '::' IDENTIFIER ('::' IDENTIFIER)? ImportAlias? ';' {
    pin = "use"
}
ImportAlias ::= as IDENTIFIER { pin = 1 }

// Types
LetTypeAscription ::= ':' (TypeReference | TupleType) { pin = 1 }
TypeAscription ::= ':' TypeReference { pin = 1 }

TypeReference ::= ('&' mut?)? PathExpr {
    name = "type"
}
TypeParameterList ::= '<' TypeParameter? (',' TypeParameter)* ','? '>'
TypeParameter ::= IDENTIFIER TypeParamBound?
TypeParamBound ::= ':' (copyable | resource)

TypeArguments ::= '<' PathExpr (',' PathExpr)*  '>'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pattern ::= TuplePattern | StructPattern | IDENTIFIER

TuplePattern ::= '(' (Pattern ','?)* ')' { pin = 1 }

StructPattern ::= PathExpr '{' (StructPatternField ','?)* '}' { pin = 2 }
StructPatternField ::= IDENTIFIER StructPatternFieldBinding?
StructPatternFieldBinding ::= ':' (StructPattern | IDENTIFIER) { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
private StatementItem ::= IfStatement | LoopStatement | LetStatement
                            | AssignmentStatement | ExprStatement

IfStatement ::= IfExpr ';'
LoopStatement ::= LoopExpr ';'
ExprStatement ::= Expr ';'

LetStatement ::= let mut? Pattern LetTypeAscription? LetStatementInit? ';' {
    pin = 1
}
LetStatementInit ::= '=' Expr { pin = 1 }
AssignmentStatement ::= Pattern '=' Expr ';' { pin = 2 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlockItem ::= Block | InlineBlock
InlineBlock ::= Expr
Block ::= '{' (StatementItem)* Expr? '}' {
    pin = 1
}
//Block ::= '{' (StatementItem ';')* Expr? '}' {
//    pin = 1
//    name = "block"
//}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= logical_or_group
        | logical_and_group
        | logical_eq_group
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | AddExprItem
        | MulExprItem
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private logical_or_group ::= OrExpr
private logical_and_group ::= AndExpr
private logical_eq_group ::= EqualsExpr | NotEqualsExpr | LessExpr | LessEqualsExpr | GreaterExpr | GreaterEqualsExpr

private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::= IfExpr
                    | LoopExpr
                    | StructLiteralExpr
                    | CallExpr
                    | PathExpr
//                    | TupleLiteralExpr
                    | LiteralExpr
                    | ParensExpr
                    | BlockExpr

OrExpr ::= Expr '||' Expr
AndExpr ::= Expr '&&' Expr
EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr
LessExpr ::= Expr '<' Expr
GreaterExpr ::= Expr '>' Expr
LessEqualsExpr ::= Expr '<=' Expr
GreaterEqualsExpr ::= Expr '>=' Expr

BitOrExpr ::= Expr '|' Expr
BitAndExpr ::= Expr '&' Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as TypeReference

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= PathExpr '{' (StructLiteralExprField ','?)* '}'
StructLiteralExprField ::= IDENTIFIER ':' Expr
ParensExpr ::= '(' Expr ')'
//TupleLiteralExpr ::= EmptyTupleExpr | ('(' Expr ',' (Expr ','?)* ')')
//EmptyTupleExpr ::= '(' ')'
LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL
BlockExpr ::= '{' Expr '}'

CallExpr ::= '::'? PathExpr CallArguments
CallArguments ::= '(' Expr? (',' Expr)? ')' { pin = 1 }

IfExpr ::= if IfCondition AnyBlockItem ElseBlock? { pin = 1 }
IfCondition ::= '(' Expr ')' { pin = 1 }
ElseBlock ::= else AnyBlockItem { pin = 1 }

LoopExpr ::= loop AnyBlockItem { pin = 1 }

BorrowExpr ::= '&' mut? Expr
PathExpr ::= (ADDRESS_LITERAL '::')? (IDENTIFIER '::')? IDENTIFIER TypeArguments?
