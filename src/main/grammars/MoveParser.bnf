{
    parserClass="org.move.lang.MvParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MvParserUtil"

    elementTypeHolderClass="org.move.lang.MvElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"
    extends(".*Expr")=Expr
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:0|[1-9][0-9]*((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]+)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        EQ = '='
        DOT         =  '.'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= (ScriptDef)+ | (AddressDef | ModuleDef)*

ScriptDef ::= script '{' (ImportStatement | FunctionDef)* '}' {
    pin = 1
}
AddressDef ::= address ADDRESS_LITERAL '{' ModuleDef* '}' {
    pin = 1
}

ModuleDef ::= module identifier '{' ModuleItemSeq '}' {
    pin = 1
    name = "module declaration"
    implements = [ "org.move.lang.core.psi.ext.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvModuleDefImplMixin"
}
private ModuleItemSeq ::= ModuleItem* { recoverWhile = "ModuleItemSeq_recover" }
private ModuleItemSeq_recover ::= !'}'

private ModuleItem ::= ImportStatement | StructDef | FunctionDef | NativeFunctionDef | ConstDef

ConstDef ::= const ConstDefInner ';' {
    pin = 1
}
private ConstDefInner ::= identifier TypeAscription '=' Expr {
    recoverWhile = "ConstDefInner_recover"
}
private ConstDefInner_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
NativeFunctionDef ::= native public? fun identifier TypeParameterList?
                     FunctionParams
                     ReturnType?
                     AcquiresType? ';'
{
    pin = 1
    name = "native function"
    implements = [ "org.move.lang.core.psi.ext.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvNativeFunctionDefImplMixin"
}

FunctionDef ::= public? fun identifier TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    Block
{
    pin = "fun"
    name = "function"
    implements = [ "org.move.lang.core.psi.ext.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvFunctionDefImplMixin"
}

// trailing comma is allowed
FunctionParams ::= '(' FunctionParamsBody ')' { pin = 1 }
private FunctionParamsBody ::= (FunctionParam ','?)* {
    recoverWhile = "FunctionParamsBody_recover"
}
private FunctionParamsBody_recover ::= !')'

FunctionParam ::= identifier TypeAscription {
    pin = 1
    recoverWhile = "FunctionParams_recover"
}
private FunctionParams_recover ::= !(','|')')

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' Type {
    pin = 1
}
// acquires T, Record
AcquiresType ::= acquires PathExpr (',' PathExpr)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct identifier TypeParameterList?
                '{'
                StructFieldDef? (',' StructFieldDef)* ','?
                '}'
{
    pin = "struct"
}
StructFieldDef ::= identifier TypeAscription

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'
ImportStatement ::= use ADDRESS_LITERAL '::' (ModuleMemberImport | ModuleImport) ';' { pin = 1 }

ModuleImport ::= Import
ModuleMemberImport ::= identifier '::' (Import | MultipleImport) { pin = 2 }

private MultipleImport ::= '{' Import MultipleImportSeq ','? '}' { pin = 1 }
private MultipleImportSeq ::= (',' Import)* {
    recoverWhile = "MultipleImportSeq_recover"
}
private MultipleImportSeq_recover ::= !((','? '}') | ';')

Import ::= identifier ImportAlias? { pin = 1 }
ImportAlias ::= as identifier { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAscription ::= ':' Type { pin = 1 }

Type ::= TupleType | TypeReference
TypeReference ::= ('&' mut?)? (address | PathExpr) {
    name = "type"
}
TupleType ::= '(' (Type ','?)* ','? ')' { pin = 1 }

TypeParameterList ::= '<' TypeParameter? (',' TypeParameter)* ','? '>'
TypeParameter ::= identifier TypeParamBound?
TypeParamBound ::= ':' (copyable | resource)

TypeArguments ::= '<' PathExpr? (',' PathExpr)* ','? '>'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pattern ::= DerefExpr | TuplePattern | StructPattern | identifier

TuplePattern ::= '(' (Pattern ','?)* ')' { pin = 1 }

StructPattern ::= PathExpr '{' (StructPatternField ','?)* '}' { pin = 2 }
StructPatternField ::= identifier StructPatternFieldBinding?
StructPatternFieldBinding ::= ':' (StructPattern | identifier) { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
//private Statement ::= IfStatement | LoopStatement | WhileStatement
//                            | LetStatement | AssignmentStatement
//                            | ExprStatement
Statement ::= StatementExpr ';'
private StatementExpr ::= IfExpr | LoopExpr | WhileExpr | LetExpr | AssignmentExpr | Expr {
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= '!;'

//IfStatement ::= IfExpr ';'
//LoopStatement ::= LoopExpr ';'
//WhileStatement ::= WhileExpr ';'

//private StatementBody ::= IfExpr

//LetStatement ::= LetStatementInner ';'
//private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
//private LetStatementInner_recover ::= !';'

//AssignmentStatement ::= AssignmentExpr ';'
//ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= Block | InlineBlock
InlineBlock ::= Expr
Block ::= '{' BlockBody '}' {
    pin = 1
}
//Block ::= '{' (StatementItem ';')* Expr? '}' {
//    pin = 1
//    name = "block"
//}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    name = "expr"
}

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessExpr | LessEqualsExpr | GreaterExpr | GreaterEqualsExpr

private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::= IfExpr
                    | LoopExpr
                    | WhileExpr
                    | LetExpr
                    | AssignmentExpr
                    | AnnotatedExpr
                    | TupleLiteralExpr
                    | StructLiteralExpr
                    | DotExpr
                    | CallExpr
                    | PathExpr
                    | LiteralExpr
                    | ParensExpr
                    | BlockExpr

EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!ltlt '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= PathExpr '{' StructLiteralExprBody '}'
{
    pin = 2
}
private StructLiteralExprBody ::= (StructLiteralExprField ','?)*
{
    recoverWhile = "StructLiteralExprBody_recover"
}
private StructLiteralExprBody_recover ::= !'}'

StructLiteralExprField ::= identifier (':' Expr)? {
    pin = 1
    recoverWhile = StructLiteralExprField_recover
}
private StructLiteralExprField_recover ::= !(','|'}')

ParensExpr ::= '(' Expr !':' ')'
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

TupleLiteralExpr ::= EmptyTupleExpr | ('(' Expr ',' (Expr ','?)* ')')
EmptyTupleExpr ::= '(' ')'
LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL
BlockExpr ::= '{' BlockBody '}' { pin = 1 }
private BlockBody ::= (Statement)* Expr? { recoverWhile = "BlockBody_recover" }
private BlockBody_recover ::= !'}'

CallExpr ::= PathExpr CallArguments { pin = 1 }

CallArguments ::= '(' Expr? (',' Expr)? ')' { pin = 1 }

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }
AssignmentExpr ::= Pattern Initializer { pin = 2 }
LetExpr ::= let mut? Pattern TypeAscription? Initializer? {
    pin = 1
}

BorrowExpr ::= '&' mut? Expr { pin = 1 }
DotExpr ::= Expr '.' identifier TypeArguments? CallArguments? { pin = 2 }

PathExpr ::= (ADDRESS_LITERAL '::')? (identifier '::')? identifier TypeArguments?

Initializer ::= '=' Expr { pin = 1 }

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>

