{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Move"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MoveElement"
    extends="org.move.lang.core.psi.impl.MoveElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MoveElementType"
    tokenTypeClass="org.move.lang.core.MoveTokenType"
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]*)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_NAME='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnuMoveariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= (ScriptDef | AddressDef | ModuleDef)*

ScriptDef ::= script ScriptBlock {
    pin = 1
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= (ImportStatement | FunctionDef)* { recoverWhile = "ScriptBlockItems_recover" }
private ScriptBlockItems_recover ::= !'}'

AddressDef ::= address ADDRESS_LITERAL AddressBlock {
    pin = 1
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1}
private AddressBlockItems ::= ModuleDef* { recoverWhile = AddressBlockItems_recover }
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= module identifier ModuleBlock {
    pin = 1
    name = "module declaration"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.resolve.MoveDefsResolveScope" ]
    mixin = "org.move.lang.core.psi.mixins.MoveModuleDefMixin"
}
ModuleBlock ::= '{' ModuleBlockItems '}' { pin = 1 }
private ModuleBlockItems ::= ModuleItem* { recoverWhile = "ModuleBlockItems_recover" }
private ModuleBlockItems_recover ::= !'}'

private ModuleItem ::= ImportStatement | StructDef | FunctionDef | NativeFunctionDef | ConstDef | SpecItem

ConstDef ::= const identifier TypeAscription ConstDef_init ';' {
    pin = 1
    implements = ["org.move.lang.core.psi.MoveNameIdentifierOwner"]
    mixin = "org.move.lang.core.psi.mixins.MoveConstDefMixin"
}
private ConstDef_init ::= '=' Expr {
    recoverWhile = "ConstDef_init_recover"
}
private ConstDef_init_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
NativeFunctionDef ::= native public? fun identifier TypeParameterList?
                     FunctionParams
                     ReturnType?
                     AcquiresType? ';'
{
    pin = 1
    name = "native function"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveNativeFunctionDefMixin"
}

FunctionDef ::= public? fun identifier TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    CodeBlock
{
    pin = "fun"
    name = "function"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.resolve.MoveResolveScope" ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionDefMixin"
}

// trailing comma is allowed
FunctionParams ::= '(' FunctionParams_body ')' {
    pin = 1
//    implements = [ "org.move.lang.core.psi.MoveDeclaringElement" ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParamsMixin"
}
private FunctionParams_body ::= (FunctionParam ','?)* {
    recoverWhile = "FunctionParams_body_recover"
}
private FunctionParams_body_recover ::= !')'

FunctionParam ::= identifier TypeAscription {
    pin = 1
    recoverWhile = "FunctionParams_recover"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParamMixin"
}
private FunctionParams_recover ::= !(','|')')

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' Type {
    pin = 1
}
// acquires T, Record
AcquiresType ::= acquires TypeRef (',' TypeRef)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct identifier
                TypeParameterList?
                StructFieldsDefBlock
{
    pin = "struct"
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.resolve.MoveResolveScope" ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructDefMixin"
}
StructFieldsDefBlock ::= '{' StructFieldsBlock_body '}' { pin = 1 }
private StructFieldsBlock_body ::= (StructFieldDef (',' StructFieldDef)* ','?)?
{
    recoverWhile = "StructFieldsBlock_body_recover"
}
private StructFieldsBlock_body_recover ::= !'}'

StructFieldDef ::= identifier StructFieldDef_type { pin = 1 }
private StructFieldDef_type ::= TypeAscription {
    recoverWhile = "StructFieldDef_type_recover"
}
private StructFieldDef_type_recover ::= !(','|'}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'
ImportStatement ::= use ADDRESS_LITERAL '::' (ModuleMemberImport | ModuleImport) ';' { pin = 1 }

ModuleImport ::= Import
ModuleMemberImport ::= identifier '::' (Import | MultipleImport) { pin = 2 }

private MultipleImport ::= '{' Import MultipleImportSeq ','? '}' { pin = 1 }
private MultipleImportSeq ::= (',' Import)* {
    recoverWhile = "MultipleImportSeq_recover"
}
private MultipleImportSeq_recover ::= !((','? '}') | ';')

Import ::= identifier ImportAlias? { pin = 1 }
ImportAlias ::= as identifier { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
private TypeAscription ::= ':' Type { pin = 1 }

Type ::= TupleType | TypeRef | LambdaType

LambdaType ::= '|' (Type (',' Type)*)? '|' Type { pin = 1 }
TypeRef ::= ('&' mut?)? QualifiedPath {
    name = "type"
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveTypeRefMixin"
}
TupleType ::= '(' (Type ','?)* ','? ')' { pin = 1 }

TypeParameterList ::= '<' (TypeParameter (',' TypeParameter)* ','?)? '>'
TypeParameter ::= identifier TypeParamBound? {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveTypeParameterMixin"
}
TypeParamBound ::= ':' (copyable | resource)

TypeArgumentList ::= '<' (TypeArgument (',' TypeArgument)* ','?)? '>'
private TypeArgument ::= TypeRef {
    recoverWhile = "TypeArgument_recover"
}
private TypeArgument_recover ::= !(','|'>')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= identifier '.' identifier { pin = 2 }

BindingPat ::= identifier {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveBindingPatMixin"
}

TuplePat ::= '(' TuplePat_body ')'
private TuplePat_body ::= (Pat (',' Pat)*)? {
    recoverWhile = "TuplePat_body_recover"
}
private TuplePat_body_recover ::= !(')'|'=')

StructPat ::= QualifiedPath StructPatFieldsBlock {
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructPatMixin"
}
StructPatFieldsBlock ::= '{' (StructPatField (',' StructPatField)* ','?)? '}' { pin = 1 }

StructPatField ::= identifier (':' Pat)? {
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructPatFieldMixin"
}
//StructPatFieldBinding ::= ':' Pat { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
//private Statement ::= IfStatement | LoopStatement | WhileStatement
//                            | LetStatement | AssignmentStatement
//                            | ExprStatement
Statement ::= StatementExpr ';'
private StatementExpr ::= IfExpr
                            | LoopExpr
                            | WhileExpr
                            | LetExpr
                            | AssignmentExpr
                            | Expr
{
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= '!;'

//InlineSpecBlock ::= spec SpecBlock { pin = 1 }

//IfStatement ::= IfExpr ';'
//LoopStatement ::= LoopExpr ';'
//WhileStatement ::= WhileExpr ';'

//private StatementBody ::= IfExpr

//LetStatement ::= LetStatementInner ';'
//private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
//private LetStatementInner_recover ::= !';'

//AssignmentStatement ::= AssignmentExpr ';'
//ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr
CodeBlock ::= '{' CodeBlock_body '}' {
    pin = 1
    implements = ["org.move.lang.core.resolve.MoveResolveScope"]
}
CodeBlockExpr ::= '{' CodeBlock_body '}' { pin = 1 }

private CodeBlock_body ::= (ImportStatement*)?
                            (Statement | SpecBlockStatement)*
                             Expr?
{
    recoverWhile = "CodeBlock_body_recover"
}
private CodeBlock_body_recover ::= !'}'

//Block ::= '{' (StatementItem ';')* Expr? '}' {
//    pin = 1
//    name = "block"
//}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExprItem
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    name = "expr"
}

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

private AssignmentExprItem ::= AssignmentExpr | LetExpr
private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
//IfExpr
//                    | LoopExpr
//                    | WhileExpr
//                    | LetExpr
                    AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
//                    | AssignmentExpr
                    | StructLiteralExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
                    | RangeExpr
                    | LiteralExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExprItem ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr eqeq_gt Expr
PartialImplyOperatorExpr ::= Expr lt_eqeq_gt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= QualifiedPath StructLiteralFieldsBlock
{
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructLiteralExprMixin"
}
StructLiteralFieldsBlock ::= '{' StructLiteralFieldsBlock_body '}' { pin = 1 }
private StructLiteralFieldsBlock_body ::= (StructLiteralExprField ','?)*
{
    recoverWhile = "StructLiteralFieldsBlock_body_recover"
}
private StructLiteralFieldsBlock_body_recover ::= !'}'

StructLiteralExprField ::= identifier (':' Expr)? {
    pin = 1
    recoverWhile = StructLiteralExprField_recover
}
private StructLiteralExprField_recover ::= !(','|'}')

ParensExpr ::= '(' Expr ')'
//private ParensExpr_body ::= Expr { recoverWhile = "ParensExpr_body_recover" }
//private ParensExpr_body_recover ::= !(':'|')'|',')
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

//TupleLiteralExpr ::= '('
//TupleLiteralExpr ::= '(' TupleLiteralExpr? ')' { pin = 2 }
//private TupleLiteralExpr_body ::= (Expr ',' (Expr ','?)*)?
LambdaExpr ::= '|' (identifier (',' identifier)*)? '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLiteralExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' (Expr ','?)* ')' { pin = 3 }

LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL

CallExpr ::= QualifiedPath CallArguments {
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveCallExprMixin"
}

CallArguments ::= '(' (CallArgument (',' CallArgument)* ','?)? ')' { pin = 1 }
private CallArgument ::= Expr {
    recoverWhile = "CallArgument_recover"
}
private CallArgument_recover ::= !(','|')')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr '=' Expr
LetExpr ::= let Pat TypeAscription? Initializer? {
    pin = 1
    mixin = "org.move.lang.core.psi.mixins.MoveLetExprMixin"
}
private Initializer ::= '=' Expr {
    pin = 1
//    recoverWhile = "Initializer_recover"
}
//private Initializer_recover ::= !(';'|'}'|')')

BorrowExpr ::= '&' mut? Expr
DotExpr ::= Expr '.' identifier
IndexExpr ::= Expr '[' Expr ']' { rightAssociative = true }
RefExpr ::= QualifiedPath {
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveRefExprMixin"
}

QualifiedPath ::= (ADDRESS_LITERAL '::')? (identifier '::')? identifier TypeArgumentList?

//PathExpr ::= (ADDRESS_LITERAL '::')? (identifier '::')? identifier TypeArguments? {
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.mixins.MovePathExprImplMixin"
//}

//Initializer ::= '=' Expr { pin = 1 }

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>


///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
//SpecDef ::= spec SpecInnerItem { pin = 1 }
private SpecItem ::= FunctionSpec
                          | ModuleSpec
                          | StructSpec
                          | SchemaDef
                          | SpecDefineFunction
                          | NativeDefineFunction

SchemaDef ::= spec schema identifier TypeParameterList? SpecBlock {
  pin = 2
  implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                 "org.move.lang.core.resolve.MoveResolveScope" ]
  mixin = "org.move.lang.core.psi.mixins.MoveSchemaDefMixin"
}

FunctionSpec ::= spec fun identifier SpecBlock {
    pin = 2
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionSpecMixin"
}
StructSpec ::= spec struct identifier SpecBlock {
    pin = 2
    implements = ["org.move.lang.core.psi.MoveTypeReferenceElement"]
    mixin = "org.move.lang.core.psi.mixins.MoveStructSpecMixin"
}
ModuleSpec ::= spec module SpecBlock { pin = 2 }

DefineFunction ::= define identifier TypeParameterList?
                                                   FunctionParams
                                                   ReturnType?
                                                   CodeBlock
{
    pin = 1
}
SpecDefineFunction ::= spec define identifier TypeParameterList?
                                                   FunctionParams
                                                   ReturnType?
                                                   SpecBlock
{
    pin = 2
}

NativeDefineFunction ::= native define identifier TypeParameterList?
                                                   FunctionParams
                                                   ReturnType? ';'
{
    pin = 2
}
SpecNativeDefineFunction ::= spec native define identifier TypeParameterList?
                                                   FunctionParams
                                                   ReturnType? ';'
{
    pin = 3
}

SpecBlockStatement ::= spec SpecBlock ';' {
    pin = 1
    extends = Statement
}

SpecBlock ::= '{' SpecBlockItem '}' { pin = 1 }
private SpecBlockItem ::= (
                                Statement
                                | DefineFunction | SpecDefineFunction
                                | NativeDefineFunction | SpecNativeDefineFunction
                                | VariableStatement | LocalVariableStatement | GlobalVariableStatement
                                | PragmaStatement
                                | AssumeStatement
                                | AssertStatement
                                | AbortsIfStatement
                                | SucceedsIfStatement
                                | RequiresStatement
                                | EnsuresStatement
                                | ModifiesStatement
                                | IncludeStatement
                                | InvariantStatement
                                | ApplyStatement
                            )*
{
    recoverWhile = SpecBlock_body_recover
}
private SpecBlock_body_recover ::= !'}'

VariableStatement ::= RefExpr ':' Type ';'
LocalVariableStatement ::= local RefExpr ':' Type ';' { pin = 1 }
GlobalVariableStatement ::= global RefExpr ':' Type ';' { pin = 1 }

PragmaStatement ::= pragma PragmaAttribute (',' PragmaAttribute)* ';' { pin = 1 }
PragmaAttribute ::= identifier ('=' LiteralExpr)?

AssumeStatement ::= assume Predicate ';' { pin = 1 }
AssertStatement ::= assert Predicate ';' { pin = 1 }
//noinspection BnfSuspiciousToken
AbortsIfStatement ::= aborts_if Predicate (with Expr)? ';' { pin = 1 }
//noinspection BnfSuspiciousToken
SucceedsIfStatement ::= succeeds_if Predicate ';' { pin = 1 }
RequiresStatement ::= requires module? Predicate ';' { pin = 1 }
EnsuresStatement ::= ensures Predicate ';' { pin = 1 }
ModifiesStatement ::= modifies Expr ';' { pin = 1 }
IncludeStatement ::= include Expr ';' { pin = 1 }

FunctionPattern ::= (public | internal)? (FUNCTION_PATTERN_NAME | IDENTIFIER) TypeArgumentList? { pin = 2 }

InvariantStatement ::= invariant (pack | unpack | module | update)? Predicate ';' { pin = 1 }
ApplyStatement ::= apply ApplySchemaName
                    to FunctionPattern (',' FunctionPattern)*
                     (except FunctionPattern (',' FunctionPattern)*)? ';' { pin = 1 }
ApplySchemaName ::= QualifiedPath ('{'
                                    ApplySchemaNameAttribute (',' ApplySchemaNameAttribute)*
                            '}')?
{
    implements = [ "org.move.lang.core.psi.MoveSchemaReferenceElement" ]
    mixin = "org.move.lang.core.psi.mixins.MoveApplySchemaNameMixin"
}
ApplySchemaNameAttribute ::= identifier ':' Expr

Predicate ::= Precondition | Expr
private Precondition ::= ((ForAllPrecondition ':' ExistsPrecondition)
                            | ExistsPrecondition
                            | ForAllPrecondition) (':' Expr)?

ForAllPrecondition ::= forall PreconditionAttribute (',' PreconditionAttribute)* ForAllWhereCondition? {
    pin = 1
//    extends = Precondition
}
ForAllWhereCondition ::= where Expr { pin = 1 }

ExistsPrecondition ::= exists PreconditionAttribute (',' PreconditionAttribute)* {
    pin = 1
//    extends = Precondition
}
PreconditionAttribute ::= ContainsPreconditionAttribute | TypePreconditionAttribute

ContainsPreconditionAttribute ::= identifier in RangeExpr {
    pin = 2
    extends = PreconditionAttribute
}
TypePreconditionAttribute ::= identifier ':' Type {
    pin = 2
    extends = PreconditionAttribute
}
