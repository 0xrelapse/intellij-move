{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Move"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MoveElement"
    extends="org.move.lang.core.psi.MoveElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MoveElementType"
    tokenTypeClass="org.move.lang.core.MoveTokenType"

    extends(".*SpecExpr")=SpecExpr
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends(".*Predicate")=Predicate
    extends("(Lambda|Ref|Path|Tuple)Type")=Type
    extends(".*SpecDef")=SpecDef

    extends(".*SpecStatement")=SpecStatement
    extends(".*Statement")=Statement

    name(".*Expr")="expression"

//    consumeTokenMethod(".*Expr") = "consumeTokenFast"

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
//        EOL_COMMENT='regexp:(//.*\n)|(//.*\R)'
//        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        PLACEHOLDER_ADDRESS_IDENT='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
        PLACEHOLDER_ADDRESS_LITERAL='regexp:@\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'

        ADDRESS_IDENT='regexp:0x[0-9a-fA-F]{1,40}'
        ADDRESS_LITERAL='regexp:@0x[0-9a-fA-F]{1,40}'

        BECH32_ADDRESS_IDENT='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
        BECH32_ADDRESS_LITERAL='regexp:@wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'

        POLKADOT_ADDRESS_IDENT='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'
        POLKADOT_ADDRESS_LITERAL='regexp:@[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'

        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u64)|(u128))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_IDENT='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'

        ADDRESS     = 'address_kw'
        FRIEND     = 'friend_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        POST     = 'post_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        INTERNAL     = 'internal_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'
        AXIOM     = 'axiom_kw'

        PACK     = 'pack_kw'
        UNPACK     = 'unpack_kw'
        UPDATE     = 'update_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        ABORTS_IF     = 'aborts_if_kw'

        CHOOSE     = 'choose_kw'
        MIN     = 'min_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnuMoveariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | ScriptDef | AddressDef | ModuleDef)*

Attr ::= '#' '[' <<comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER AttrItemArguments?
AttrItemArguments ::= '(' <<comma_sep_items AttrItemArgument>> ')'
AttrItemArgument ::= IDENTIFIER '=' LiteralExpr

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

ScriptDef ::= script ScriptBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveImportStatementsOwner" ]
    mixin = "org.move.lang.core.psi.ext.MoveScriptDefMixin"
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | const | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= ImportStatement | ConstDef | FunctionDef

private address ::= <<addressKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MoveAddressDefMixin"
//    stubClass = "org.move.lang.core.stubs.impl.MoveAddressDefStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplFactoryKt.factory"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= ModuleDef*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= Attr* module (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "module"
    name = "module declaration"
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveImportStatementsOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveModuleDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//    stubClass = "org.move.lang.core.stubs.impl.MoveModuleDefStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplFactoryKt.factory"
}
ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
}
private ModuleBlockItems ::= ModuleItem*
//{
//    recoverWhile = "ModuleBlockItems_recover"
//}
//private ModuleBlockItems_recover ::= !'}'

private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | const | struct | spec | Attr
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= ImportStatement | FriendStatement
                            | StructDef | FunctionDef
                            | NativeStructDef | NativeFunctionDef
                            | SpecFunctionDef | SpecNativeFunctionDef | UninterpretedSpecFunctionDef
                            | ConstDef
                            | SpecDef
//private ModuleItem_item ::= ImportStatement | StructDef | NativeStructDef
//                            | FunctionDef | FunctionVisibilityContainer
//                            | NativeFunctionDef | ConstDef | ItemSpecDef

ConstDef ::= const IDENTIFIER TypeAnnotation Initializer ';'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveConstDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//    recoverWhile = ModuleItem_recover
}
//private ConstDef_init ::= '=' Expr
//{
//    recoverWhile = "ConstDef_init_recover"
//}
//private ConstDef_init_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
//NativeFunctionDef ::= native FunctionSignature

//NativeFunctionDef ::= native FunctionVisibilityModifier?
//                      fun IDENTIFIER TypeParameterList?
//                         FunctionParameterList
//                         ReturnType?
//                         AcquiresType? ';'
//{
//    pin = "fun"
//    name = "native function"
//    implements = [
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
//    mixin = "org.move.lang.core.psi.mixins.MoveNativeFunctionDefMixin"
//    recoverWhile = Item_recover
//}

//private NativeDef ::=
//{
//    pin = 1
////    recoverWhile = Item_recover
//}

SpecFunctionDef ::= (spec FunctionSignature) SpecBlock
SpecNativeFunctionDef ::= (spec native) FunctionSignature ';' { pin = 1 }
UninterpretedSpecFunctionDef ::= spec FunctionSignature ';'

FunctionDefSpecStatement ::= FunctionSignature SpecBlock
NativeFunctionDefSpecStatement ::= native FunctionSignature ';' { pin = 1 }
UninterpretedFunctionDefSpecStatement ::= FunctionSignature ';'

NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';'
{
    pin = 2
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
NativeStructDef ::= native StructSignature ';'
{
    pin = 2
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionSignatureWithOptionalVisibility ::= FunctionSignatureVisibility | FunctionSignature
private FunctionSignatureVisibility ::= FunctionVisibilityModifier FunctionSignature { pin = 1 }
FunctionSignature ::= fun IDENTIFIER TypeParameterList?
                          FunctionParameterList
                          ReturnType? AcquiresType?
{
    pin = "fun"
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionSignatureMixin"
    recoverWhile = "FunctionSignature__recover"
}
private FunctionSignature__recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

FunctionDef ::= Attr* FunctionSignatureWithOptionalVisibility CodeBlock
{
    pin = 2
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//    recoverWhile = Item_recover
}
//NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';'

//FunctionDef ::= fun IDENTIFIER TypeParameterList?
//                    FunctionParameterList
//                    ReturnType? AcquiresType?
//                    CodeBlock
//{
//    pin = "fun"
//    name = "function"
//    implements = [
//        "org.move.lang.core.psi.MoveNameIdentifierOwner"
////        "org.move.lang.core.psi.MoveTypeParametersOwner"
//        "org.move.lang.core.psi.MoveFunctionSignatureOwner"
//    ]
////    extends = "org.move.lang.core.psi.MoveStubbedNamedElementImpl<?>"
//    mixin = "org.move.lang.core.psi.mixins.MoveFunctionDefMixin"
//    recoverWhile = Item_recover
////    stubClass = "org.move.lang.core.stubs.MoveFunctionDefStub"
////    elementTypeFactory = "org.move.lang.core.stubs.StubImplementationsKt.factory"
//}

private friend ::= <<friendKeyword>>
FunctionVisibilityModifier ::= public ('(' (script | friend) ')')?

//private FunctionReturnItems ::= ReturnType? AcquiresType?
//{
//    recoverWhile = FunctionReturnItems_recover
//}
//private FunctionReturnItems_recover ::= !(CodeBlock | ';' | Item_first)

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')'
{
    pin = 1
//    extends = "org.move.lang.core.psi.MoveStubbedElementImpl<?>"
//    stubClass = "org.move.lang.core.stubs.PlaceholderStub"
//    elementTypeFactory = "org.move.lang.core.stubs.StubImplementationsKt.factory"
}
//private FunctionParameterList_body ::= <<comma_separated_list FunctionParameter>> {
//    recoverWhile = "FunctionParameterList_body_recover"
//}
//private FunctionParameterList_body_recover ::= !')'

private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= IDENTIFIER TypeAnnotation
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveFunctionParameterMixin"
}

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<comma_sep_items PathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructSignature ::= struct IDENTIFIER TypeParameterList? AbilitiesList?
{
    pin = "struct"
    implements = [
        "org.move.lang.core.psi.MoveTypeParametersOwner"
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MoveStructSignatureMixin"
}

StructDef ::= Attr* StructSignature StructFieldsDefBlock
{
    pin = 2
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

AbilitiesList ::= has <<comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructFieldsDefBlock ::= '{' StructFieldDef_with_recover* '}' { pin = 1 }
private StructFieldDef_with_recover ::= !'}' StructFieldDef (',' | &'}')
{
    pin = 1
    recoverWhile = StructFieldDef_recover
}
private StructFieldDef_recover ::= !('}' | IDENTIFIER)

StructFieldDef ::= IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.types.HasType"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructFieldDefMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'

FriendStatement ::= friend FQModuleRef ';' { pin = 1 }

ImportStatement ::= Attr* use (ModuleItemsImport | ModuleImport) ';'
{
    pin = "use"
}
//private ImportStatement_recover ::= !ModuleItem_first
//private ImportStatement_body ::= ModuleItemsImport | ModuleImport

//private ImportStatement_body ::= AddressRef '::' Import
//{
//    recoverWhile = ImportStatement_body_recover
//}
//private ImportStatement_body_recover ::= !';'

//Import ::= ItemImport | ModuleImport
ModuleImport ::= FQModuleRef ImportAlias?
{
//    extends = Import
    name = "qual path to imported item"
    implements = [
        "org.move.lang.core.psi.MoveNamedElement"
//        "org.move.lang.core.psi.MoveReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveModuleImportMixin"
}
ModuleItemsImport ::= FQModuleRef '::' (ItemImport | MultiItemImport)
{
    pin = 2
    name = "qual path to imported item"
//    extends = Import
}

MultiItemImport ::= '{' <<comma_sep_items MultiItemImport_member_with_recovery>> '}'
{
    pin = 1
}
private MultiItemImport_member_with_recovery ::= !('}' | ';' | <<eof>>) ItemImport
{
    pin = 1
}

//private MultiImportedItem_items ::= <<comma_sep_items ImportedItem>>
//{
//    recoverWhile = MultiImportedItem_items_recovery
//}
//private MultiImportedItem_items_recovery ::= !'}'

ItemImport ::= IDENTIFIER ImportAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.move.lang.core.psi.MoveNamedElement"
        "org.move.lang.core.psi.MoveReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveItemImportMixin"
}
ImportAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MoveImportAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type { pin = 1 }

Type ::= RefType | PathType | TupleType | LambdaType
{
    implements = ["org.move.lang.core.types.HasType"]
    mixin = "org.move.lang.core.psi.ext.MoveTypeMixin"
}

RefType ::= RefTypeStart Type
{
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MoveRefTypeMixin"
}
RefTypeStart ::= ('&' mut?)

PathType ::= Path
{
    name = "type"
    mixin = "org.move.lang.core.psi.ext.MovePathTypeMixin"
}

TupleType ::= '(' TupleTypeItem_with_recover* ')' { pin = 1 }
private TupleTypeItem_with_recover ::= !')' Type (',' | &')')
{
    pin = 1
    recoverWhile = TupleTypeItem_recover
}
private TupleTypeItem_recover ::= !(')' | '{' | IDENTIFIER)

LambdaType ::= '|' <<comma_sep_items Type>>? '|' Type { pin = 1 }

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
}
private TypeParameter_with_recover ::= !'>' TypeParameter (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | IDENTIFIER)

TypeParameter ::= phantom? IDENTIFIER TypeParamBound? {
    pin = 2
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.types.HasType" ]
    mixin = "org.move.lang.core.psi.mixins.MoveTypeParameterMixin"
}
TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<comma_sep_items (TypeArgument &(','|'>'))>>? '>'
TypeArgument ::= Type

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [ "org.move.lang.core.psi.MoveNameIdentifierOwner"
                   "org.move.lang.core.types.HasType" ]
    mixin = "org.move.lang.core.psi.ext.MoveBindingPatMixin"
}

TuplePat ::= '(' <<comma_sep_items Pat>>? ')'
//private TuplePat_body ::= (<<comma_sep_list Pat>>)? {
//    recoverWhile = "TuplePat_body_recover"
//}
//private TuplePat_body_recover ::= !(')'|'=')

StructPat ::= Path StructPatFieldsBlock
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

StructPatField ::= IDENTIFIER StructPatFieldBinding? {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveNameIdentifierOwner"
        "org.move.lang.core.psi.MoveStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat { pin = 1 }

//private StructPatField_recovery ::= !(',' | '}' | IDENTIFIER)


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
Statement ::= LetStatement | ExprStatement
{
    implements = ["org.move.lang.core.types.HasType"]
    mixin = "org.move.lang.core.psi.ext.MoveStatementMixin"
}
LetStatement ::= let Pat TypeAnnotation? Initializer? ';' {
    pin = 1
//    implements = [
//        "org.move.lang.core.types.HasType"
//    ]
//    mixin = "org.move.lang.core.psi.mixins.MoveLetStatementMixin"
}

ExprStatement ::= (ExprStatement_items ';')
private ExprStatement_items ::= IfExpr
                            | LoopExpr
                            | WhileExpr
//                            | LetExpr
//                            | AssignmentExpr
                            | Expr
{
    recoverWhile = "StatementExpr_recover"
}
private StatementExpr_recover ::= !(';' | '}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlock_items  '}'
{
    pin = 1
//    implements = [ "org.move.lang.core.psi.MoveImportStatementsOwner" ]
}

private CodeBlock_items ::= ImportStatement*
                            (Statement | SpecBlockSpecStatement)*
                            (Expr | SpecBlockExpr)?
{
    recoverWhile = "CodeBlock_items_recover"
}
private CodeBlock_items_recover ::= !'}'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
        | RangeExpr
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    implements = ["org.move.lang.core.types.HasType"]
    mixin = "org.move.lang.core.psi.ext.MoveExprMixin"
}
//private SpecExpr ::= Expr | AggregatePredicate

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

//private AssignmentExprItem ::= LetExpr | AssignmentExpr
private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
//IfExpr
//                    | LoopExpr
//                    | WhileExpr
//                    | LetExpr
                    AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
//                    | AssignmentExpr
                    | StructLiteralExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
//                    | RangeExpr
                    | LiteralExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBooleanExprMixin"
}
GreaterExpr ::= Expr (!gtgt '>') Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBooleanExprMixin"
}
LessEqualsExpr ::= Expr lteq Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBooleanExprMixin"
}
GreaterEqualsExpr ::= Expr gteq Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBooleanExprMixin"
}

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type
{
    mixin = "org.move.lang.core.psi.ext.MoveCastExprMixin"
}

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

MulExpr ::= Expr '*' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMulExprMixin"
}
DivExpr ::= Expr '/' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveDivExprMixin"
}
PlusExpr ::= Expr '+' Expr
{
    mixin = "org.move.lang.core.psi.ext.MovePlusExprMixin"
}
MinusExpr ::= Expr '-' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMinusExprMixin"
}

ModExpr ::= Expr '%' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveModExprMixin"
}

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExprItem ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr eqeq_gt Expr
PartialImplyOperatorExpr ::= Expr lt_eqeq_gt Expr

BangExpr ::= '!' Expr
{ mixin = "org.move.lang.core.psi.ext.MoveBangExprMixin" }

DerefExpr ::= '*' Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveDerefExprMixin"
}
CopyExpr ::= copy Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveCopyExprMixin"
}
MoveExpr ::= move Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveMoveExprMixin"
}

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= Path StructLiteralFieldsBlock
{
    mixin = "org.move.lang.core.psi.ext.MoveStructLiteralExprMixin"
}
StructLiteralFieldsBlock ::= '{' StructLiteralField_with_recover* '}' { pin = 1 }

private StructLiteralField_with_recover ::= !'}' StructLiteralField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLiteralField_recover
}
private StructLiteralField_recover ::= !('}' | IDENTIFIER)

StructLiteralField ::= IDENTIFIER StructLiteralFieldAssignment?
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MoveStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveStructLiteralFieldMixin"
//    recoverWhile = StructLiteralExprField_recover
}

//private StructLiteralExprField_recover ::= !(',' | '}')
StructLiteralFieldAssignment ::= ':' Expr { pin = 1 }

ParensExpr ::= '(' Expr ')'
{
    mixin = "org.move.lang.core.psi.ext.MoveParensExprMixin"
}
//private ParensExpr_body ::= Expr { recoverWhile = "ParensExpr_body_recover" }
//private ParensExpr_body_recover ::= !(':'|')'|',')
//private ParensExprBody ::= Expr { recoverWhile = "ParensExprBody_recover"}
//private ParensExprBody_recover ::= !(':'|')')

//TupleLiteralExpr ::= '('
//TupleLiteralExpr ::= '(' TupleLiteralExpr? ')' { pin = 2 }
//private TupleLiteralExpr_body ::= (Expr ',' (Expr ','?)*)?
LambdaExpr ::= '|' <<comma_sep_items IDENTIFIER>> '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLiteralExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LiteralExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | PLACEHOLDER_ADDRESS_LITERAL
                | ADDRESS_LITERAL
                | BECH32_ADDRESS_LITERAL
                | POLKADOT_ADDRESS_LITERAL
{
    mixin = "org.move.lang.core.psi.ext.MoveLiteralExprMixin"
}

CallExpr ::= (Path &'(') CallArguments
{
    pin = 1
//    implements = ["org.move.lang.core.psi.MoveQualNameReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveCallExprMixin"
}

CallArguments ::= '(' <<comma_sep_items (Expr &(','|')'))>>? ')' { pin = 1 }
//private CallArgument ::= Expr {
//    recoverWhile = "CallArgument_recover"
//}
//private CallArgument_recover ::= !(','|')')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }
//private IfExprBody ::= AnyBlock {
//    recoverWhile = "IfExprBody_recover"
//}
//private IfExprBody_recover ::= !';'

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr Initializer { rightAssociative = true }

Initializer ::= '=' Expr {
    pin = 1
//    recoverWhile = "Initializer_recover"
}
//private Initializer_recover ::= !(';'|'}'|')')

BorrowExpr ::= '&' mut? Expr
{
    mixin = "org.move.lang.core.psi.ext.MoveBorrowExprMixin"
}

DotExpr ::= Expr '.' StructFieldRef
{
    mixin = "org.move.lang.core.psi.ext.MoveDotExprMixin"
}

StructFieldRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.MoveStructFieldReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveStructFieldRefMixin"
}

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

RefExpr ::= Path
{
//    implements = [
//        "org.move.lang.core.psi.MoveQualNameReferenceElement"
//    ]
    mixin = "org.move.lang.core.psi.ext.MoveRefExprMixin"
}

//private Path ::= QualPath | LocalPath
//fake Path ::= (ModuleRef '::')? IDENTIFIER? TypeArgumentList?
//{
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MovePathMixin"
//}

//LocalPath ::= IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }
//QualPath ::= ModuleRef '::' IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }

// TODO: add NamedAddress parsing with Move.toml info and switch FQModulePathIdent and ModulePathIdent
Path ::= (ModulePathIdent | FQModulePathIdent | LocalPathIdent) TypeArgumentList?
{
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MovePathMixin"
}

fake PathIdent ::= ((FQModuleRef | ModuleRef) '::')? IDENTIFIER?

LocalPathIdent ::= IDENTIFIER { elementType = PathIdent }
ModulePathIdent ::= ModuleRef '::' IDENTIFIER
{
    pin = 2
    elementType = PathIdent
}
FQModulePathIdent ::= FQModuleRef '::' IDENTIFIER
{
    pin = 1
    elementType = PathIdent
}

ModuleRef ::= IDENTIFIER | FQModuleRef
{
    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveModuleRefMixin"
}

//ImportedModuleRef ::= IDENTIFIER
//{
//    extends = ModuleRef
//    mixin = "org.move.lang.core.psi.ext.MoveImportedModuleRefMixin"
//}

FQModuleRef ::= AddressRef '::' IDENTIFIER
{
    pin = 2
    extends = ModuleRef
    implements = [
        "org.move.lang.core.psi.MoveFQModuleReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MoveFQModuleRefMixin"
}

AddressRef ::= NamedAddress
                | PLACEHOLDER_ADDRESS_IDENT
                | BECH32_ADDRESS_IDENT
                | POLKADOT_ADDRESS_IDENT
                | ADDRESS_IDENT
NamedAddress ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.NamedAddressReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MoveNamedAddressMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private include ::= <<includeKeyword>>
private choose ::= <<chooseKeyword>>
private min ::= <<minKeyword>>

private invariant ::= <<invariantKeyword>>
private axiom ::= <<axiomKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

SpecDef ::= NameSpecDef | ModuleSpecDef | SchemaSpecDef

NameSpecDef ::= (spec IDENTIFIER) SpecBlock
//{
//    pin = 1
//    implements = ["org.move.lang.core.psi.MoveReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MoveNameSpecDefMixin"
//}
ModuleSpecDef ::= (spec module) SpecBlock { pin = 1 }

SchemaSpecDef ::= (spec schema) IDENTIFIER TypeParameterList? SpecBlock {
  pin = 1
  implements = [
    "org.move.lang.core.psi.MoveTypeParametersOwner"
    "org.move.lang.core.psi.MoveNameIdentifierOwner" ]
  mixin = "org.move.lang.core.psi.mixins.MoveSchemaDefMixin"
}

SpecBlockExpr ::= spec SpecBlock
SpecBlockSpecStatement ::= SpecBlockExpr ';'

SpecBlock ::= '{'
                SpecBlockStatement_with_recover*
                SpecBlockFinishingExpr_with_recover?
              '}'
{
    pin = 1
}

private SpecBlockStatement_with_recover ::= !('}' | <<eof>>) SpecStatement
private SpecBlockFinishingExpr_with_recover ::= !('}' | <<eof>>) SpecBlockFinishingExpr

SpecStatement ::= ImportStatement
                               | VariableSpecStatement
                               | LocalVariableSpecStatement
                               | GlobalVariableSpecStatement
                               | FunctionDefSpecStatement
                               | NativeFunctionDefSpecStatement
                               | UninterpretedFunctionDefSpecStatement
                               | PragmaSpecStatement
                               | AssumeSpecStatement
                               | AssertSpecStatement
                               | AbortsIfSpecStatement
                               | RequiresSpecStatement
                               | EnsuresSpecStatement
                               | ModifiesSpecStatement
                               | IncludeSpecStatement
                               | InvariantSpecStatement
                               | AxiomSpecStatement
                               | ApplySpecStatement
                               | EmitsSpecStatement
                               | AggregatePredicateSpecStatement
                               | SpecBlockSpecStatement
                               | LetSpecStatement
                               | ChooseSpecStatement
                               | Statement
private SpecBlockFinishingExpr ::= SpecExpr | AggregateExpr | Expr

VariableSpecStatement ::= RefExpr TypeAnnotation ';' { pin = 2 }

LocalVariableSpecStatement ::= local RefExpr TypeAnnotation ';' { pin = 1 }
GlobalVariableSpecStatement ::= global RefExpr TypeAnnotation ';' { pin = 1 }

private post ::= <<postKeyword>>
LetSpecStatement ::= (let post?) Pat TypeAnnotation? Initializer? ';' { pin = 1 }
PragmaSpecStatement ::= pragma <<comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' Expr)?

SpecExpr ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr
                | RequiresSpecExpr | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr | AxiomSpecExpr
{
    extends = Expr
}

AssumeSpecStatement ::= AssumeSpecExpr ';'
AssumeSpecExpr ::= assume Predicate { pin = 1 }

AssertSpecStatement ::= AssertSpecExpr ';'
AssertSpecExpr ::= assert Predicate { pin = 1 }

AbortsIfSpecStatement ::= AbortsIfSpecExpr ';'
//noinspection BnfSuspiciousToken
AbortsIfSpecExpr ::= aborts_if Predicate WithExpr? { pin = 1 }
WithExpr ::= with Expr { pin = 1 }

RequiresSpecStatement ::= RequiresSpecExpr ';'
RequiresSpecExpr ::= requires module? Predicate { pin = 1 }

EnsuresSpecStatement ::= EnsuresSpecExpr ';'
EnsuresSpecExpr ::= ensures Predicate { pin = 1 }

ModifiesSpecStatement ::= ModifiesSpecExpr ';'
ModifiesSpecExpr ::= modifies Expr { pin = 1 }

IncludeSpecStatement ::= include SpecVisibility? Expr ';' { pin = 1 }

private PatternVis ::= <<patternVisibility>>
private PatternIdent ::= <<patternIdent>>

//fake FunctionPatternIdent ::= ('*' | IDENTIFIER)+
FunctionPattern ::= PatternVis? PatternIdent TypeArgumentList? { pin = 2 }
//FunctionPattern ::= (public | internal)? IDENTIFIER TypeArgumentList? { pin = 2 }

private InvariantModifier ::= <<invariantModifierKeyword>>
InvariantSpecStatement ::= InvariantSpecExpr ';'
InvariantSpecExpr ::= invariant InvariantModifier? TypeParameterList? Predicate { pin = 1 }

AxiomSpecStatement ::= AxiomSpecExpr ';'
AxiomSpecExpr ::= axiom TypeParameterList? Predicate { pin = 1 }
//InvariantModifier ::= pack | unpack | module | update

SpecVisibility ::= '[' <<comma_sep_items SpecVisibilityModifier>> ']' { pin = 1 }

SpecVisibilityModifier ::= IDENTIFIER
//SpecVisibilityModifier ::= global | isolated | deactivated
//                                | concrete | abstract
//                                | assert | assume

EmitsSpecStatement ::= emits Expr to Expr EmitsCondition? ';' { pin = 1 }
EmitsCondition ::= if Expr { pin = 1 }

ApplySpecStatement ::= apply ApplySchemaName
                    to <<comma_sep_items FunctionPattern>>
                     ( except <<comma_sep_items FunctionPattern>> )? ';'
{
    pin = 1
}

ApplySchemaName ::= Path
                    ('{' <<comma_sep_items ApplySchemaNameAttribute>> '}')?
//{
//    implements = [
//        "org.move.lang.core.psi.MoveQualSchemaReferenceElement"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MoveApplySchemaNameMixin"
//}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

Predicate ::= SpecVisibility? (AggregateExpr | Expr)

AggregatePredicateSpecStatement ::= AggregateExpr ';'
AggregateExpr ::= QuantifierExpr (':' Expr)?
{
    rightAssociative = true
}

QuantifierWhere ::= where Expr
{
    pin = 1
//    rightAssociative = true
}

private QuantifierExpr ::= ForallQuantifier | ExistsQuantifier
ForallQuantifier ::= forall QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?
ExistsQuantifier ::= exists QuantifierBindings
                        (QuantifierWhere)? (':' QuantifierExpr)?

ChooseSpecStatement ::= choose min? QuantifierBindings
                        (QuantifierWhere)?
                        (':' QuantifierExpr)? ';'
{
    pin = 1
}

QuantifierBindings ::= <<comma_sep_items QuantifierBind>>
QuantifierBind ::= RangeQuantifierBind | TypeQuantifierBind

RangeQuantifierBind ::= IDENTIFIER in RangeExpr {
    pin = 2
    extends = QuantifierBind
}
TypeQuantifierBind ::= IDENTIFIER ':' Type {
    pin = 2
    extends = QuantifierBind
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
