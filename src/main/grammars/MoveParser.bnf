{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"
//
//  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"

    elementTypeHolderClass="org.move.lang.MoveElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"
    extends(".*Expr")=Expr
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\Z)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:0|[1-9][0-9]*'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]+)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
//        LOOP_KW='loop'
//        BREAK_KW='break'
//        CONTINUE_KW='continue'
//        LET_KW='let'
//        MUT_KW='mut'
//        IF_KW='if'
//        ELSE_KW='else'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * macro rules are snake_cased: list_item
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= ScriptBlock | (AddressBlock | ModuleDef)*

ScriptBlock ::= script '{' (Import | FunctionDef)* '}' {
    pin = "script"
}
AddressBlock ::= address ADDRESS_LITERAL '{' ModuleDef* '}' {
    pin = "address"
}
ModuleDef ::= module IDENTIFIER '{' ModuleItem* '}' {
    pin = "module"
}
private ModuleItem ::= Import | StructDef | FunctionDef

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
FunctionDef ::= public? fun IDENTIFIER TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    FunctionBodyBlock
{
    pin = "fun"
    name = "function declaration"
}

// trailing comma is allowed
FunctionParams ::= '(' (FunctionParam ','?)* ')' {
    pin = 1
}
FunctionParam ::= IDENTIFIER TypeAscription

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' (TypeReference | TupleType) {
    pin = 1
}
TupleType ::= '(' (TypeReference ','?)* ','? ')' { pin = 1 }
// acquires T, Record
AcquiresType ::= acquires PathExpr (',' PathExpr)* ','? { pin = 1 }

FunctionBodyBlock ::= '{' BlockBody '}' { pin = 1 }
///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct IDENTIFIER TypeParameterList?
                '{'
                StructFieldDef? (',' StructFieldDef)*
                '}'
{
    pin = "struct"
}

StructFieldDef ::= IDENTIFIER TypeAscription

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction'
Import ::= use ADDRESS_LITERAL '::' IDENTIFIER ('::' IDENTIFIER)? ImportAlias? ';' {
    pin = "use"
}
ImportAlias ::= as IDENTIFIER { pin = 1 }

// Types
LetTypeAscription ::= ':' (TypeReference | TupleType) { pin = 1 }
TypeAscription ::= ':' TypeReference { pin = 1 }

TypeReference ::= ('&' mut?)? PathExpr {
    name = "type"
}
TypeParameterList ::= '<' TypeParameter? (',' TypeParameter)* ','? '>'
TypeParameter ::= IDENTIFIER TypeParamBound?
TypeParamBound ::= ':' (copyable | resource)

TypeArguments ::= '<' PathExpr (',' PathExpr)*  '>'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
private StatementItem ::= if_statement | LetDecl | loop_statement
                    | break_statement | continue_statement | abort_statement | return_statement
                    | assignment_statement | expr_statement

loop_statement ::= loop Block ';' {
    pin = "loop"
}
if_statement ::= if '(' Expr ')' Block ElseBlock? ';' {
    pin = "if"
}
ElseBlock ::= else Block { pin = 1 }

Block ::= '{'? BlockBody '}'?
private BlockBody ::= StatementItem* Expr?

Pattern ::= TuplePattern | StructPattern | IDENTIFIER

TuplePattern ::= '(' (Pattern ','?)* ')' { pin = 1 }

StructPattern ::= PathExpr '{' (StructPatternField ','?)* '}' { pin = 2 }
StructPatternField ::= IDENTIFIER StructPatternFieldBinding?
StructPatternFieldBinding ::= ':' (StructPattern | IDENTIFIER) { pin = 1 }

LetDecl ::= let mut? Pattern LetTypeAscription? LetInitValue? ';' {
    pin = 1
}
LetInitValue ::= '=' Expr { pin = 1 }

continue_statement ::= continue
break_statement ::= break
return_statement ::= return Expr { pin = 1 }
abort_statement ::= abort Expr ';' { pin = 1 }
assignment_statement ::= Pattern '=' Expr ';' { pin = 2 }
expr_statement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= logical_or_group
        | logical_and_group
        | logical_eq_group
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | add_group
        | mul_group
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

private mul_group ::= DivExpr | MulExpr | ModExpr
private add_group ::= PlusExpr | MinusExpr
private logical_or_group ::= OrExpr
private logical_and_group ::= AndExpr
private logical_eq_group ::= EqualsExpr | NotEqualsExpr | LessExpr | LessEqualsExpr | GreaterExpr | GreaterEqualsExpr

private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
private AtomExpr ::= StructLiteralExpr
                    | CallExpr
                    | PathExpr
                    | TupleLiteralExpr
                    | LiteralExpr
                    | ParensExpr

OrExpr ::= Expr '||' Expr
AndExpr ::= Expr '&&' Expr
EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr
LessExpr ::= Expr '<' Expr
GreaterExpr ::= Expr '>' Expr
LessEqualsExpr ::= Expr '<=' Expr
GreaterEqualsExpr ::= Expr '>=' Expr

BitOrExpr ::= Expr '|' Expr
BitAndExpr ::= Expr '&' Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as TypeReference

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr { pin = 1 }
MoveExpr ::= move Expr { pin = 1 }

StructLiteralExpr ::= PathExpr '{' (StructLiteralExprField ','?)* '}'
StructLiteralExprField ::= IDENTIFIER ':' Expr
ParensExpr ::= '(' Expr ')'
TupleLiteralExpr ::= ('(' ')') | ('(' Expr ',' (Expr ','?)* ')')
LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL

CallExpr ::= '::'? PathExpr CallArguments
CallArguments ::= '(' (Expr ','?)* ')' { pin = 1 }

BorrowExpr ::= '&' mut? Expr
PathExpr ::= (ADDRESS_LITERAL '::')? (IDENTIFIER '::')? IDENTIFIER TypeArguments?
