{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MvElement"
    extends="org.move.lang.core.psi.MvElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MvElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"

//    extends(".*SpecExpr")=SpecExpr
    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
//    extends(".*Predicate")=Predicate_item
    extends("(Lambda|Ref|Path|Tuple)Type")=Type
    extends(".*SpecDef")=SpecDef

//    extends(".*SpecStatement")=SpecStatement
    extends(".*Statement")=Statement

    name(".*Expr")="expression"

//    consumeTokenMethod(".*Expr") = "consumeTokenFast"

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
//        EOL_COMMENT='regexp:(//.*\n)|(//.*\R)'
//        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        PLACEHOLDER_ADDRESS_IDENT='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
//        PLACEHOLDER_ADDRESS_LITERAL='regexp:@\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'

        ADDRESS_IDENT='regexp:0x[0-9a-fA-F]{1,40}'
//        ADDRESS_LITERAL='regexp:@0x[0-9a-fA-F]{1,40}'

        BECH32_ADDRESS_IDENT='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
//        BECH32_ADDRESS_LITERAL='regexp:@wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'

        POLKADOT_ADDRESS_IDENT='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'
//        POLKADOT_ADDRESS_LITERAL='regexp:@[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'

        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u64)|(u128))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u64)|(u128))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_IDENT='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'

        ADDRESS     = 'address_kw'
        FRIEND     = 'friend_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        POST     = 'post_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        INTERNAL     = 'internal_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'
        AXIOM     = 'axiom_kw'

        PACK     = 'pack_kw'
        UNPACK     = 'unpack_kw'
        UPDATE     = 'update_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        ABORTS_IF     = 'aborts_if_kw'

        CHOOSE     = 'choose_kw'
        MIN     = 'min_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | ScriptDef | AddressDef | ModuleDef)*

Attr ::= '#' '[' <<comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER AttrItemArguments?
AttrItemArguments ::= '(' <<comma_sep_items AttrItemArgument>> ')'
AttrItemArgument ::= IDENTIFIER '=' LitExpr

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

ScriptDef ::= script ScriptBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MvImportStatementsOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvScriptDefMixin"
}
ScriptBlock ::= '{' ScriptBlockItems '}' { pin = 1 }
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | const | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= ImportStatement | ConstDef | FunctionInner

private address ::= <<addressKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MvAddressDefMixin"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= ModuleDef*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

ModuleDef ::= Attr* module (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "module"
    name = "module declaration"
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.MvImportStatementsOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
}
private ModuleBlockItems ::= ModuleItem*
private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | const | struct | spec | friend | Attr
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= ImportStatement | FriendStatement
                            | StructItem
                            | FunctionItem
                            | SpecFunctionDef | SpecNativeFunctionDef | UninterpretedSpecFunctionDef
                            | ConstDef
                            | SpecDef

ConstDef ::= const BindingPat TypeAnnotation Initializer ';'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
SpecFunctionDef ::= (spec FunctionSignature) SpecBlock
SpecNativeFunctionDef ::= (spec native) FunctionSignature ';' { pin = 1 }
UninterpretedSpecFunctionDef ::= spec FunctionSignature ';'

FunctionDefSpecStatement ::= FunctionSignature SpecBlock
NativeFunctionDefSpecStatement ::= native FunctionSignature ';' { pin = 1 }
UninterpretedFunctionDefSpecStatement ::= FunctionSignature ';'

fake Struct_ ::= Attr* native? struct IDENTIFIER? TypeParameterList? AbilitiesList?
                        (';' | StructFieldsDefBlock)?
{
    implements = [
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.move.lang.core.psi.MvTypeParametersOwner"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructMixin"
}

private StructInnerFirst ::= struct
StructInner ::= Attr* StructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList?
                            StructFieldsDefBlock
{
    pin = StructInnerFirst
    elementType = Struct_
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private NativeStructInnerFirst ::= native struct
NativeStructInner ::= Attr* NativeStructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList? ';'
{
    pin = NativeStructInnerFirst
    elementType = Struct_
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private StructItem ::= StructInner | NativeStructInner

//NativeStructDef ::= native StructSignature ';'
//{
//    pin = 2
//    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
//    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//}

fake Function ::= Attr* native? FunctionVisibilityModifier? native?
                    fun? IDENTIFIER? TypeParameterList? FunctionParameterList?
                        ReturnType? AcquiresType?
                        (';' | CodeBlock)?
{
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.move.lang.core.psi.MvTypeParametersOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFunctionMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionInnerNoVisFirst ::= fun { pin = FunctionVisibilityModifier }
private FunctionInnerVisFirst ::= FunctionVisibilityModifier fun { pin = 1 }
private FunctionInnerFirst ::= FunctionInnerVisFirst | FunctionInnerNoVisFirst

FunctionInner ::= Attr* FunctionInnerFirst FunctionSignatureInner CodeBlock
{
    pin = FunctionInnerFirst
    elementType = Function
//    recoverWhile = "FunctionSignature__recover"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private NativeFunctionInnerNoVisFirst ::= native fun
private NativeFunctionInnerVisFirst ::= ((native FunctionVisibilityModifier)
                                        | (FunctionVisibilityModifier native)) fun { pin = 1 }
private NativeFunctionInnerFirst ::= NativeFunctionInnerNoVisFirst | NativeFunctionInnerVisFirst

//private NativeFunctionInnerFirst ::= ((native FunctionVisibilityModifier?)
//                                        | (FunctionVisibilityModifier? native) ) fun
//                                        { pin = FunctionVisibilityModifier }
NativeFunctionInner ::= Attr* NativeFunctionInnerFirst FunctionSignatureInner ';'
{
    pin = NativeFunctionInnerFirst
    elementType = Function
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionItem ::= NativeFunctionInner | FunctionInner

private FunctionSignatureInner ::= IDENTIFIER TypeParameterList? FunctionParameterList ReturnType? AcquiresType?
{
    recoverWhile = "FunctionSignature__recover"
}

//private FunctionSignatureWithOptionalVisibility ::= FunctionSignatureVisibility | FunctionSignature
//private FunctionSignatureVisibility ::= FunctionVisibilityModifier FunctionSignature { pin = 1 }
FunctionSignature ::= fun IDENTIFIER TypeParameterList?
                          FunctionParameterList
                          ReturnType? AcquiresType?
{
    pin = "fun"
    recoverWhile = "FunctionSignature__recover"
}
private FunctionSignature__recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

//FunctionDef ::= Attr* native? FunctionVisibilityModifier native?
//NativeFunctionDef ::= native FunctionSignatureWithOptionalVisibility ';'
//{
//    pin = 2
//    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
//    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//}

//FunctionDef ::= Attr* FunctionSignatureWithOptionalVisibility CodeBlock
//{
//    pin = 2
//    implements = [
//        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
//    ]
//    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//}

private friend ::= <<friendKeyword>>
FunctionVisibilityModifier ::= public ('(' (script | friend) ')')?

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')' { pin = 1 }
private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= BindingPat TypeAnnotation { pin = 1 }

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<comma_sep_items PathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
//StructSignature ::= struct IDENTIFIER TypeParameterList? AbilitiesList?
//{
//    pin = "struct"
//    implements = [
//        "org.move.lang.core.psi.MvTypeParametersOwner"
//        "org.move.lang.core.psi.MvNameIdentifierOwner"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MvStructMixin"
//}

//StructDef ::= Attr* StructSignature StructFieldsDefBlock
//{
//    pin = 2
//    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
//    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//}

AbilitiesList ::= has <<comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructFieldsDefBlock ::= '{' StructFieldDef_with_recover* '}' { pin = 1 }
private StructFieldDef_with_recover ::= !'}' StructFieldDef (',' | &'}')
{
    pin = 1
    recoverWhile = StructFieldDef_recover
}
private StructFieldDef_recover ::= !('}' | IDENTIFIER)

StructFieldDef ::= IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructFieldDefMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'

FriendStatement ::= friend FQModuleRef ';' { pin = 1 }

ImportStatement ::= Attr* use (ModuleItemsImport | ModuleImport) ';'
{
    pin = "use"
}
ModuleImport ::= (AddressRef !'::') | FQModuleRef ImportAlias?
{
    name = "qual path to module"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleImportMixin"
}
ModuleItemsImport ::= FQModuleRef '::' (ItemImport | MultiItemImport)
{
    pin = 2
    name = "qual path to imported item"
}

MultiItemImport ::= '{' <<comma_sep_items MultiItemImport_member_with_recovery>> '}'
{
    pin = 1
}
private MultiItemImport_member_with_recovery ::= !('}' | ';' | <<eof>>) ItemImport
{
    pin = 1
}

ItemImport ::= IDENTIFIER ImportAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
        "org.move.lang.core.psi.MvMandatoryReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvItemImportMixin"
}
ImportAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvImportAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type { pin = 1 }

Type ::= RefType | PathType | TupleType | LambdaType

RefType ::= RefTypeStart Type
{
    pin = 1
}
RefTypeStart ::= ('&' mut?)

PathType ::= Path
{
    name = "type"
}

TupleType ::= '(' TupleTypeItem_with_recover* ')' { pin = 1 }
private TupleTypeItem_with_recover ::= !')' Type (',' | &')')
{
    pin = 1
    recoverWhile = TupleTypeItem_recover
}
private TupleTypeItem_recover ::= !(')' | '{' | IDENTIFIER)

LambdaType ::= '|' <<comma_sep_items Type>>? '|' Type { pin = 1 }

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
}
private TypeParameter_with_recover ::= !'>' TypeParameterImpl (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | phantom | IDENTIFIER)

fake TypeParameter ::= phantom? IDENTIFIER? TypeParamBound? {
    pin = 2
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.mixins.MvTypeParameterMixin"
}

private TypeParameterImpl ::= PlainTypeParameter | PhantomTypeParameter
PlainTypeParameter ::= IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }
PhantomTypeParameter ::= phantom IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }

TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<comma_sep_items (TypeArgument &(','|'>'))>>? '>'
TypeArgument ::= Type

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat

WildPat ::= '_'
DerefPat ::= '*' Pat
BorrowPat ::= '&' Pat
DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvBindingPatMixin"
}

TuplePat ::= '(' <<comma_sep_items Pat>>? ')'

StructPat ::= Path StructPatFieldsBlock
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

StructPatField ::= (BindingPat !':') | (IDENTIFIER StructPatFieldBinding)
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvStructFieldReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
Statement ::= LetStatement | ExprStatement

SpecExprStatement ::= (SpecExpr_item !'}') ';' { pin = 1 }
private SpecExpr_item ::= SpecExprStatement_items | ExprStatement_items
{
    recoverWhile = SpecExprStatement_recover
}
private SpecExprStatement_recover ::= !(';' | '}' | SpecExprStatement_first)
private SpecExprStatement_first ::= let | if | while
                                    | include | apply | pragma | emits | choose | assume | assert | ensures

private SpecExprStatement_items ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr
                | RequiresSpecExpr | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr | AxiomSpecExpr
//{
//    recoverWhile = ExprStatement_recover
//}

LetStatement ::= let Pat TypeAnnotation? Initializer? ';' { pin = 1 }

ExprStatement ::= (ExprStatement_items !('}')) ';' { pin = 1 }
private ExprStatement_items ::= IfExpr
                                | LoopExpr
                                | WhileExpr
                                | SpecBlockExpr
                                | Expr
{
    recoverWhile = "ExprStatement_recover"
}
private ExprStatement_recover ::= !(';' | '}' | ExprStatement_first)
private ExprStatement_first ::= let | if | while
//                                | <<specOnly include>>
//                                | <<specOnly apply>>
//                                | <<specOnly pragma>>
//                                | <<specOnly emits>>
//                                | <<specOnly choose>>
//                                | <<specOnly ensures>> | <<specOnly invariant>>
//                                | <<specOnly include>> | <<specOnly aborts_if>>
//                                | <<specOnly choose>> | <<specOnly axiom>>

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlock_items '}' { pin = 1 }

private CodeBlock_items ::= ImportStatement*
                            Statement*
                            ExprStatement_items?
{
    recoverWhile = "CodeBlock_items_recover"
}
private CodeBlock_items_recover ::= !('}' | <<eof>>)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
        | SpecVisRestrictedExpr
        | RangeExpr
        | AggregateExpr
        | ImplyOperatorsExpr_items
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr

private ControlFlowExpr ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
                    AnnotatedExpr
                    | TupleLitExpr
                    | ParensExpr
                    | StructLitExpr
                    | DotExpr
                    | IndexExpr
                    | (CallExpr | MacroCallExpr)
                    | RefExpr
                    | LambdaExpr
                    | LitExpr
                    | CodeBlockExpr

EqualsExpr ::= Expr (!eqeq_gt '==') Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!(ltlt | lt_eqeq_gt) '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

MulExpr ::= Expr '*' Expr
DivExpr ::= Expr '/' Expr
PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr
ModExpr ::= Expr '%' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

private ImplyOperatorsExpr_items ::= ImplyOperatorExpr | PartialImplyOperatorExpr
ImplyOperatorExpr ::= Expr <<specOnly eqeq_gt>> Expr
PartialImplyOperatorExpr ::= Expr <<specOnly lt_eqeq_gt>> Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr

CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
//private ReturnExpr ::= EmptyReturnExpr | ValueReturnExpr
//EmptyReturnExpr ::= return { elementType = ReturnExpr }
//ValueReturnExpr ::= return Expr { elementType = ReturnExpr }

AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLitExpr ::= Path StructLitFieldsBlock
StructLitFieldsBlock ::= '{' StructLitField_with_recover* '}' { pin = 1 }

private StructLitField_with_recover ::= !'}' StructLitField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLitField_recover
}
private StructLitField_recover ::= !('}' | IDENTIFIER)

StructLitField ::= IDENTIFIER StructLitFieldInit?
{
    implements = [
        "org.move.lang.core.psi.MvStructFieldLitReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructLitFieldMixin"
}

private StructLitFieldInit ::= ':' Expr { pin = 1 }

ParensExpr ::= '(' Expr !':' ')'

LambdaExpr ::= '|' <<comma_sep_items IDENTIFIER>> '|' Expr { pin = 1 }
RangeExpr ::= Expr '..' Expr

TupleLitExpr ::= EmptyTupleExpr | TupleExpr
private EmptyTupleExpr ::= '(' ')'
private TupleExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LitExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
//                | PLACEHOLDER_ADDRESS_LITERAL
//                | ADDRESS_LITERAL
//                | BECH32_ADDRESS_LITERAL
//                | POLKADOT_ADDRESS_LITERAL
//                | ('@' NamedAddress)
                | AddressLit
AddressLit ::= '@' AddressRef { pin = 1 }

CallExpr ::= (Path &'(') CallArgumentList { pin = 1 }
CallArgumentList ::= '(' <<comma_sep_items (Expr &(','|')'))>>? ')' { pin = 1 }

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr Initializer { rightAssociative = true }
Initializer ::= '=' Expr { pin = 1 }

BorrowExpr ::= '&' mut? Expr
DotExpr ::= Expr '.' StructFieldRef

StructFieldRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.MvStructFieldReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvStructFieldRefMixin"
}

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

RefExpr ::= Path

//private Path ::= QualPath | LocalPath
//fake Path ::= (ModuleRef '::')? IDENTIFIER? TypeArgumentList?
//{
//    implements = ["org.move.lang.core.psi.MvReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MvPathMixin"
//}

//LocalPath ::= IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }
//QualPath ::= ModuleRef '::' IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }

Path ::= (ModulePathIdent | FQModulePathIdent | LocalPathIdent) TypeArgumentList?
{
    implements = ["org.move.lang.core.psi.MvPathReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvPathMixin"
}

fake PathIdent ::= ((FQModuleRef | ModuleRef) '::')? IDENTIFIER?

LocalPathIdent ::= IDENTIFIER { elementType = PathIdent }
ModulePathIdent ::= ModuleRef ('::' !(IDENTIFIER '::')) IDENTIFIER
{
    pin = 2
    elementType = PathIdent
}
FQModulePathIdent ::= FQModuleRef '::' IDENTIFIER
{
    pin = 1
    elementType = PathIdent
}

ModuleRef ::= IDENTIFIER | FQModuleRef
{
    implements = ["org.move.lang.core.psi.MvReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvModuleRefMixin"
}

FQModuleRef ::= AddressRef '::' IDENTIFIER
//FQModuleRef ::= (FQModuleRefUseStart | FQModuleRefStart) IDENTIFIER
{
    pin = 2
    extends = ModuleRef
    implements = [
        "org.move.lang.core.psi.MvFQModuleReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFQModuleRefMixin"
}
private FQModuleRefUseStart ::= AddressRef '::' { pin = 2 }
private FQModuleRefStart ::= AddressRef '::'

AddressRef ::= NamedAddress
                | PLACEHOLDER_ADDRESS_IDENT
                | BECH32_ADDRESS_IDENT
                | POLKADOT_ADDRESS_IDENT
                | ADDRESS_IDENT
NamedAddress ::= IDENTIFIER
{
    implements = ["org.move.lang.core.psi.NamedAddressReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvNamedAddressMixin"
}

/// Macros
MacroCallExpr ::= MacroIdent CallArgumentList { pin = 1 }
MacroIdent ::= IDENTIFIER '!'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private include ::= <<includeKeyword>>
private choose ::= <<chooseKeyword>>
private min ::= <<minKeyword>>

private invariant ::= <<invariantKeyword>>
private axiom ::= <<axiomKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

private SpecItem_first ::= assert | assume | modifies | requires | ensures | aborts_if | include | choose | axiom
                         | invariant | pragma | local | global | emits
private SpecItem_recover ::= !('}' | <<eof>> | SpecItem_first)

SpecDef ::= NameSpecDef | ModuleSpecDef | SchemaSpecDef

NameSpecDef ::= (spec IDENTIFIER) SpecBlock
//{
//    pin = 1
//    implements = ["org.move.lang.core.psi.MvReferenceElement"]
//    mixin = "org.move.lang.core.psi.ext.MvNameSpecDefMixin"
//}
ModuleSpecDef ::= (spec module) SpecBlock { pin = 1 }

SchemaSpecDef ::= (spec schema) IDENTIFIER TypeParameterList? SpecBlock {
  pin = 1
  implements = [
    "org.move.lang.core.psi.MvTypeParametersOwner"
    "org.move.lang.core.psi.MvNameIdentifierOwner" ]
  mixin = "org.move.lang.core.psi.mixins.MvSchemaDefMixin"
}

SpecBlockExpr ::= spec SpecBlock
//SpecBlockStatement ::= SpecBlockExpr ';'

SpecBlock ::= <<spec SpecBlock_inner>>
private SpecBlock_inner ::= '{' SpecBlock_items '}' { pin = 1 }
private SpecBlock_items ::= (SpecStatement | ExprStatement)* (SpecExprStatement_items | ExprStatement_items)?
{
    recoverWhile = SpecBlock_items_recover
}
private SpecBlock_items_recover ::= !('}' | <<eof>>)

//private SpecExpr_item ::= SpecExprStatement_items | ExprStatement_items

//private SpecItem ::= !('}' | <<eof>>) SpecStatement
//{
//    pin = 1
//    recoverWhile = SpecItem_recover
//}

//private SpecItemExpr ::= SpecBlockFinishingExpr
private SpecBlockStatement_with_recover ::= SpecStatement
//private SpecBlockFinishingExpr_with_recover ::= !('}' | <<eof>>) SpecBlockFinishingExpr

private SpecStatement ::= ImportStatement
                       | VariableSpecStatement
                       | LocalVariableSpecStatement
                       | GlobalVariableSpecStatement
                       | FunctionDefSpecStatement
                       | NativeFunctionDefSpecStatement
                       | UninterpretedFunctionDefSpecStatement
                       | PragmaSpecStatement
//                               | AssumeSpecStatement
//                               | AssertSpecStatement
//                               | AbortsIfSpecStatement
//                               | RequiresSpecStatement
//                               | EnsuresSpecStatement
//                               | ModifiesSpecStatement
                               | IncludeSpecStatement
//                               | InvariantSpecStatement
//                               | AxiomSpecStatement
                               | ApplySpecStatement
                               | EmitsSpecStatement
//                               | AggregatePredicateSpecStatement
//                               | SpecBlockSpecStatement
                               | LetSpecStatement
                               | ChooseSpecStatement
//                               | ExprSpecStatement
                               | SpecExprStatement
//{
//    recoverWhile = SpecStatement_recover
//}
//private SpecStatement_recover ::= !'}'

//ExprSpecStatement ::= ExprSpecStatement_item ';'
//private ExprSpecStatement_item ::= SpecExpr | AggregateExpr | Expr
//
//private SpecBlockFinishingExpr ::= SpecExpr | AggregateExpr | Expr

VariableSpecStatement ::= IDENTIFIER TypeAnnotation ';' { pin = 2 }

LocalVariableSpecStatement ::= local IDENTIFIER TypeAnnotation ';' { pin = 1 }
GlobalVariableSpecStatement ::= global IDENTIFIER TypeAnnotation ';' { pin = 1 }

private post ::= <<postKeyword>>
LetSpecStatement ::= (let post?) Pat TypeAnnotation? Initializer? ';' { pin = 1 }
PragmaSpecStatement ::= pragma <<comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' Expr)?

//{
//    extends = Expr
//}

//AssumeSpecStatement ::= AssumeSpecExpr ';'
AssumeSpecExpr ::= assume Expr { pin = 1 }

//AssertSpecStatement ::= AssertSpecExpr ';'
AssertSpecExpr ::= assert Expr { pin = 1 }

//AbortsIfSpecStatement ::= AbortsIfSpecExpr ';'
//noinspection BnfSuspiciousToken
AbortsIfSpecExpr ::= aborts_if Expr AbortsWith? { pin = 1 }
AbortsWith ::= with Expr { pin = 1 }

//private SpecExpr_first ::= aborts_if

//RequiresSpecStatement ::= RequiresSpecExpr ';'
RequiresSpecExpr ::= requires module? Expr { pin = 1 }

//EnsuresSpecStatement ::= EnsuresSpecExpr ';'
//private EnsuresSpecExpr_body ::= EnsuresSpecExpr

EnsuresSpecExpr ::= ensures Expr { pin = 1 }

//ModifiesSpecStatement ::= ModifiesSpecExpr ';'
ModifiesSpecExpr ::= modifies Expr { pin = 1 }

IncludeSpecStatement ::= include SpecVisibility? Expr ';' { pin = 1 }

private PatternVis ::= <<patternVisibility>>
private PatternIdent ::= <<patternIdent>>

//fake FunctionPatternIdent ::= ('*' | IDENTIFIER)+
FunctionPattern ::= PatternVis? PatternIdent TypeArgumentList? { pin = 2 }
//FunctionPattern ::= (public | internal)? IDENTIFIER TypeArgumentList? { pin = 2 }

private InvariantModifier ::= <<invariantModifierKeyword>>
//InvariantSpecStatement ::= InvariantSpecExpr ';'
InvariantSpecExpr ::= invariant InvariantModifier? TypeParameterList? Expr { pin = 1 }

//AxiomSpecStatement ::= AxiomSpecExpr ';'
AxiomSpecExpr ::= axiom TypeParameterList? Expr { pin = 1 }
//InvariantModifier ::= pack | unpack | module | update

SpecVisibility ::= '[' SpecVisibility_items ']' { pin = 1 }
private SpecVisibility_items ::= SpecVisibilityModifier ( ',' SpecVisibilityModifier )* ','?
{
    recoverWhile = SpecVisibility_items_recover
}
private SpecVisibility_items_recover ::= !(']' | <<eof>>)

SpecVisibilityModifier ::= IDENTIFIER
//SpecVisibilityModifier ::= global | isolated | deactivated
//                                | concrete | abstract
//                                | assert | assume

EmitsSpecStatement ::= emits Expr to Expr EmitsCondition? ';'
{
    pin = 1
}
//private EmitsStatement_body ::= Expr to Expr EmitsCondition?
//{ recoverWhile = ExprStatement_recover }

EmitsCondition ::= if Expr { pin = 1 }

ApplySpecStatement ::= apply ApplySchemaName
                        to <<comma_sep_items FunctionPattern>>
                         ( except <<comma_sep_items FunctionPattern>> )? ';'
{
    pin = 1
}

ApplySchemaName ::= Path
                    ('{' <<comma_sep_items ApplySchemaNameAttribute>> '}')?
//{
//    implements = [
//        "org.move.lang.core.psi.MvQualSchemaReferenceElement"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MvApplySchemaNameMixin"
//}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

SpecVisRestrictedExpr ::= SpecVisibility Expr

//AggregatePredicateSpecStatement ::= AggregateExpr ';'
AggregateExpr ::= Quantifier_items (':' Expr)?
{
    rightAssociative = true
}

QuantifierWhere ::= where Expr
{
    pin = 1
//    rightAssociative = true
}

private Quantifier_items ::= ForallQuantifier | ExistsQuantifier
ForallQuantifier ::= <<specOnly forall>> QuantifierBindings
                        (QuantifierWhere)? (':' Quantifier_items)? { pin = 1 }
ExistsQuantifier ::= <<specOnly exists>> QuantifierBindings
                        (QuantifierWhere)? (':' Quantifier_items)? { pin = 1 }

ChooseSpecStatement ::= choose min? QuantifierBindings
                        (QuantifierWhere)?
                        (':' Quantifier_items)? ';'
{
    pin = 1
}

QuantifierBindings ::= <<comma_sep_items QuantifierBind>>
QuantifierBind ::= RangeQuantifierBind | TypeQuantifierBind

RangeQuantifierBind ::= IDENTIFIER in RangeExpr {
    pin = 2
    extends = QuantifierBind
}
TypeQuantifierBind ::= IDENTIFIER ':' Type {
    pin = 2
    extends = QuantifierBind
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
