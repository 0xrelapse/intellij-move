{
    parserClass="org.move.lang.MvParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MvParserUtil"

    elementTypeHolderClass="org.move.lang.MvElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"
    extends(".*Expr")=Expr
    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
        LINE_COMMENT='regexp:(//.*\n)|(//.*\R)'
        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        ADDRESS_LITERAL='regexp:0x[0-9a-fA-F]{1,40}'
        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:0|[1-9][0-9]*((u8)|(u64)|(u128))?'
        HEX_STRING_LITERAL='regexp:x"([A-F0-9a-f]+)"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        EQ = '='

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= (ScriptBlock)+ | (AddressBlock | ModuleDef)*

ScriptBlock ::= script '{' (ImportDef | FunctionDef)* '}' {
    pin = "script"
}
AddressBlock ::= address ADDRESS_LITERAL '{' ModuleDef* '}' {
    pin = "address"
}
ModuleDef ::= module IDENTIFIER '{' ModuleItem* '}' {
    pin = "module"
}
private ModuleItem ::= ImportDef | StructDef | FunctionDef | ConstDef

ConstDef ::= const ConstDefInner ';' { pin = 1 }
private ConstDefInner ::= IDENTIFIER TypeAscription '=' Expr {
    recoverWhile = "ConstDefInner_recover"
}
private ConstDefInner_recover ::= !';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
FunctionDef ::= public? fun IDENTIFIER TypeParameterList?
                    FunctionParams
                    ReturnType?
                    AcquiresType?
                    Block
{
    pin = "fun"
    name = "function declaration"
}

// trailing comma is allowed
FunctionParams ::= '(' FunctionParamsBody ')' { pin = 1 }
private FunctionParamsBody ::= (FunctionParam ','?)* {
    recoverWhile = "FunctionParamsBody_recover"
}
private FunctionParamsBody_recover ::= !')'

FunctionParam ::= IDENTIFIER TypeAscription {
    pin = 1
    recoverWhile = "FunctionParams_recover"
}
private FunctionParams_recover ::= !(','|')')

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' Type {
    pin = 1
}
// acquires T, Record
AcquiresType ::= acquires PathExpr (',' PathExpr)* ','? { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
StructDef ::= resource? struct IDENTIFIER TypeParameterList?
                '{'
                StructFieldDef? (',' StructFieldDef)* ','?
                '}'
{
    pin = "struct"
}
StructFieldDef ::= IDENTIFIER TypeAscription

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction'
ImportDef ::= use ADDRESS_LITERAL '::' IDENTIFIER ('::' IDENTIFIER)? ImportAlias? ';' {
    pin = "use"
}
ImportAlias ::= as IDENTIFIER { pin = 1 }

// Types
TypeAscription ::= ':' Type { pin = 1 }

Type ::= TupleType | TypeReference
TypeReference ::= ('&' mut?)? PathExpr {
    name = "type"
}
TupleType ::= '(' (Type ','?)* ','? ')' { pin = 1 }

TypeParameterList ::= '<' TypeParameter? (',' TypeParameter)* ','? '>'
TypeParameter ::= IDENTIFIER TypeParamBound?
TypeParamBound ::= ':' (copyable | resource)

TypeArguments ::= '<' PathExpr? (',' PathExpr)* ','? '>' { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pattern ::= DerefExpr | TuplePattern | StructPattern | IDENTIFIER

TuplePattern ::= '(' (Pattern ','?)* ')' { pin = 1 }

StructPattern ::= PathExpr '{' (StructPatternField ','?)* '}' { pin = 2 }
StructPatternField ::= IDENTIFIER StructPatternFieldBinding?
StructPatternFieldBinding ::= ':' (StructPattern | IDENTIFIER) { pin = 1 }

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////
private StatementItem ::= IfStatement | LoopStatement | WhileStatement
                            | LetStatement | AssignmentStatement
                            | ExprStatement

IfStatement ::= IfExpr ';'
LoopStatement ::= LoopExpr ';'
WhileStatement ::= WhileExpr ';'

LetStatement ::= LetStatementInner ';'
private LetStatementInner ::= LetExpr { recoverWhile = "LetStatementInner_recover"}
private LetStatementInner_recover ::= !';'

AssignmentStatement ::= AssignmentExpr ';'
ExprStatement ::= Expr ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlockItem ::= Block | InlineBlock
InlineBlock ::= Expr
Block ::= '{' BlockBody '}' {
    pin = 1
}
//Block ::= '{' (StatementItem ';')* Expr? '}' {
//    pin = 1
//    name = "block"
//}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= logical_or_group
        | logical_and_group
        | logical_eq_group
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr
{
    name = "expr"
}

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private logical_or_group ::= OrExpr
private logical_and_group ::= AndExpr
private logical_eq_group ::= EqualsExpr | NotEqualsExpr | LessExpr | LessEqualsExpr | GreaterExpr | GreaterEqualsExpr

private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::= IfExpr
                    | LoopExpr
                    | WhileExpr
                    | LetExpr
                    | AssignmentExpr
                    | TupleLiteralExpr
                    | AnnotatedExpr
                    | StructLiteralExpr
                    | DotExpr
                    | CallExpr
                    | PathExpr
                    | LiteralExpr
                    | ParensExpr
                    | BlockExpr

EqualsExpr ::= Expr '==' Expr
NotEqualsExpr ::= Expr '!=' Expr

OrExpr ::= Expr oror Expr
AndExpr ::= Expr andand Expr

LessExpr ::= Expr (!ltlt '<') Expr
GreaterExpr ::= Expr (!gtgt '>') Expr
LessEqualsExpr ::= Expr lteq Expr
GreaterEqualsExpr ::= Expr gteq Expr

BitOrExpr ::= Expr (!oror '|') Expr
BitAndExpr ::= Expr (!andand '&') Expr
BitXorExpr ::= Expr '^' Expr

CastExpr ::= Expr as Type
AnnotatedExpr ::= '(' Expr TypeAscription ')' { pin = 3 }

DivExpr ::= Expr '/' Expr
MulExpr ::= Expr '*' Expr
ModExpr ::= Expr '%' Expr

PlusExpr ::= Expr '+' Expr
MinusExpr ::= Expr '-' Expr

LeftShiftExpr ::= Expr ltlt Expr
RightShiftExpr ::= Expr gtgt Expr

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr
CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

StructLiteralExpr ::= PathExpr '{' StructLiteralExprBody '}'
{
    pin = 2
}
private StructLiteralExprBody ::= (StructLiteralExprField ','?)*
{
    recoverWhile = "StructLiteralExprBody_recover"
}
private StructLiteralExprBody_recover ::= !'}'

StructLiteralExprField ::= IDENTIFIER (':' Expr)? {
    pin = 1
    recoverWhile = StructLiteralExprField_recover
}
private StructLiteralExprField_recover ::= !(','|'}')

ParensExpr ::= '(' Expr ')'
//private ParensExpr_recovery ::= !':'

TupleLiteralExpr ::= EmptyTupleExpr | ('(' Expr ',' (Expr ','?)* ')')
EmptyTupleExpr ::= '(' ')'
LiteralExpr ::= BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | ADDRESS_LITERAL
BlockExpr ::= '{' BlockBody '}' { pin = 1 }
private BlockBody ::= (StatementItem)* Expr? { recoverWhile = "BlockBody_recover" }
private BlockBody_recover ::= !'}'

CallExpr ::= PathExpr CallArguments { pin = 1 }

CallArguments ::= '(' Expr? (',' Expr)? ')' { pin = 1 }

IfExpr ::= if IfCondition AnyBlockItem ElseBlock? { pin = 1 }
IfCondition ::= '(' Expr ')' { pin = 1 }
ElseBlock ::= else AnyBlockItem { pin = 1 }

LoopExpr ::= loop AnyBlockItem { pin = 1 }
WhileExpr ::= while IfCondition AnyBlockItem { pin = 1 }
AssignmentExpr ::= Pattern Initializer { pin = 2 }
LetExpr ::= let mut? Pattern TypeAscription? Initializer? {
    pin = 1
}

BorrowExpr ::= '&' mut? Expr { pin = 1 }
DotExpr ::= Expr '.' IDENTIFIER TypeArguments? CallArguments? { pin = 2 }

PathExpr ::= (ADDRESS_LITERAL '::')? (IDENTIFIER '::')? IDENTIFIER TypeArguments?

Initializer ::= '=' Expr { pin = 1 }

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>

